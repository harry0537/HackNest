import React, { createContext, useContext, useState, useCallback } from 'react';
import toast from 'react-hot-toast';

const SimplePentestContext = createContext();

// Security Testing Frameworks with prescribed methodologies
const FRAMEWORKS = {
  ptes: {
    id: 'ptes',
    name: 'PTES (Penetration Testing Execution Standard)',
    description: 'Comprehensive penetration testing methodology with 5 phases',
    phases: [
      {
        id: 'target-input',
        title: 'Pre-Engagement & Target Input',
        order: 0,
        description: 'Initial target information and scope definition',
        tools: []
      },
      {
        id: 'intelligence-gathering',
        title: 'Intelligence Gathering',
        order: 1,
        description: 'Active and passive information collection',
        tools: [
          { id: 'whois', name: 'WHOIS Information Gathering', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Information Gathering', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Amass Subdomain Enumeration', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'subfinder', name: 'Subfinder Subdomain Discovery', endpoint: '/api/recon/subfinder', priority: 2 },
          { id: 'assetfinder', name: 'Assetfinder Asset Discovery', endpoint: '/api/recon/assetfinder', priority: 3 },
          { id: 'theharvester', name: 'TheHarvester OSINT Gathering', endpoint: '/api/recon/theharvester', priority: 3 },
          { id: 'subdomain', name: 'Subdomain Enumeration', endpoint: '/api/recon/subdomains', priority: 4 }
        ]
      },
      {
        id: 'threat-modeling',
        title: 'Threat Modeling & Vulnerability Analysis',
        order: 2,
        description: 'Network discovery and service enumeration',
        tools: [
          { id: 'nmap-quick', name: 'Network Discovery Scan', endpoint: '/api/scan/quick', priority: 1 },
          { id: 'masscan', name: 'Masscan Fast Port Scan', endpoint: '/api/scan/masscan', priority: 1 },
          { id: 'nmap-service', name: 'Service Version Detection', endpoint: '/api/scan/service', priority: 2 },
          { id: 'nmap-scripts', name: 'Nmap Script Scanning', endpoint: '/api/scan/nmap/scripts', priority: 3 },
          { id: 'nmap-vulners', name: 'Nmap Vulnerability Scanning', endpoint: '/api/scan/nmap/vulners', priority: 3 },
          { id: 'udp-scan', name: 'UDP Port Scanning', endpoint: '/api/scan/udp-scan', priority: 4 },
          { id: 'nuclei', name: 'Nuclei Vulnerability Scanner', endpoint: '/api/exploit/nuclei', priority: 4 }
        ]
      },
      {
        id: 'exploitation',
        title: 'Exploitation',
        order: 3,
        description: 'Vulnerability exploitation and payload delivery',
        tools: [
          { id: 'http-headers', name: 'HTTP Security Headers Analysis', endpoint: '/api/web/headers', priority: 1 },
          { id: 'ssl-analysis', name: 'SSL/TLS Configuration Review', endpoint: '/api/web/ssl', priority: 1 },
          { id: 'nikto', name: 'Nikto Web Vulnerability Scanner', endpoint: '/api/web/nikto', priority: 2 },
          { id: 'gobuster', name: 'Gobuster Directory Enumeration', endpoint: '/api/web/gobuster', priority: 2 },
          { id: 'wapiti', name: 'Wapiti Web Vulnerability Scanner', endpoint: '/api/web/wapiti', priority: 3 },
          { id: 'zap-baseline', name: 'OWASP ZAP Baseline Scan', endpoint: '/api/web/zap-baseline', priority: 3 },
          { id: 'ffuf', name: 'FFuF Web Fuzzer', endpoint: '/api/web/ffuf', priority: 4 },
          { id: 'xss-test', name: 'Cross-Site Scripting (XSS) Test', endpoint: '/api/web/xss', priority: 4 },
          { id: 'sql-injection', name: 'SQL Injection Assessment', endpoint: '/api/exploit/sqlmap', priority: 5 },
          { id: 'hydra', name: 'Hydra Password Attack', endpoint: '/api/exploit/hydra', priority: 5 },
          { id: 'metasploit', name: 'Metasploit Exploitation', endpoint: '/api/exploit/metasploit', priority: 6 }
        ]
      },
      {
        id: 'post-exploitation',
        title: 'Post-Exploitation & Reporting',
        order: 4,
        description: 'Privilege escalation, data exfiltration, and comprehensive reporting',
        tools: [
          { id: 'john', name: 'John the Ripper Password Cracking', endpoint: '/api/exploit/john', priority: 1 }
        ]
      }
    ]
  },
  
  owasp: {
    id: 'owasp',
    name: 'OWASP Testing Guide v4.2',
    description: 'Web application security testing methodology',
    phases: [
      {
        id: 'target-input',
        title: 'Information Gathering',
        order: 0,
        description: 'Collect preliminary information about the target',
        tools: []
      },
      {
        id: 'fingerprinting',
        title: 'Fingerprinting Web Server & Applications',
        order: 1,
        description: 'Identify web server, technologies, and frameworks',
        tools: [
          { id: 'whois', name: 'WHOIS Information', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Information', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Amass Subdomain Enumeration', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'subfinder', name: 'Subfinder Discovery', endpoint: '/api/recon/subfinder', priority: 2 },
          { id: 'http-headers', name: 'HTTP Headers Analysis', endpoint: '/api/web/headers', priority: 3 },
          { id: 'ssl-analysis', name: 'SSL/TLS Analysis', endpoint: '/api/web/ssl', priority: 3 },
          { id: 'theharvester', name: 'TheHarvester OSINT', endpoint: '/api/recon/theharvester', priority: 4 }
        ]
      },
      {
        id: 'configuration-testing',
        title: 'Configuration and Deployment Testing',
        order: 2,
        description: 'Test infrastructure and application configuration',
        tools: [
          { id: 'nmap-quick', name: 'Network Infrastructure Analysis', endpoint: '/api/scan/quick', priority: 1 },
          { id: 'nmap-service', name: 'Service Configuration Review', endpoint: '/api/scan/service', priority: 2 },
          { id: 'gobuster', name: 'File and Directory Enumeration', endpoint: '/api/web/gobuster', priority: 3 },
          { id: 'ffuf', name: 'Parameter and Content Discovery', endpoint: '/api/web/ffuf', priority: 4 },
          { id: 'nikto', name: 'Web Server Configuration Analysis', endpoint: '/api/web/nikto', priority: 4 }
        ]
      },
      {
        id: 'vulnerability-testing',
        title: 'Vulnerability Testing',
        order: 3,
        description: 'Test for common web application vulnerabilities',
        tools: [
          { id: 'nuclei', name: 'Automated Vulnerability Scan', endpoint: '/api/exploit/nuclei', priority: 1 },
          { id: 'wapiti', name: 'Comprehensive Web Vulnerability Scanner', endpoint: '/api/web/wapiti', priority: 2 },
          { id: 'zap-baseline', name: 'OWASP ZAP Security Baseline', endpoint: '/api/web/zap-baseline', priority: 2 },
          { id: 'xss-test', name: 'Cross-Site Scripting Testing', endpoint: '/api/web/xss', priority: 3 },
          { id: 'sql-injection', name: 'SQL Injection Testing', endpoint: '/api/exploit/sqlmap', priority: 3 },
          { id: 'nmap-vulners', name: 'Network Vulnerability Assessment', endpoint: '/api/scan/nmap/vulners', priority: 4 }
        ]
      },
      {
        id: 'reporting',
        title: 'Report Generation',
        order: 4,
        description: 'Compile findings into OWASP-compliant report',
        tools: []
      }
    ]
  },
  
  nist: {
    id: 'nist',
    name: 'NIST SP 800-115',
    description: 'Technical Guide to Information Security Testing and Assessment',
    phases: [
      {
        id: 'target-input',
        title: 'Planning',
        order: 0,
        description: 'Test planning and preparation phase',
        tools: []
      },
      {
        id: 'discovery',
        title: 'Discovery',
        order: 1,
        description: 'Network discovery and asset identification',
        tools: [
          { id: 'whois', name: 'Target Information Discovery', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Discovery', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Advanced Subdomain Discovery', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'assetfinder', name: 'Asset Discovery', endpoint: '/api/recon/assetfinder', priority: 2 },
          { id: 'theharvester', name: 'OSINT Information Gathering', endpoint: '/api/recon/theharvester', priority: 3 },
          { id: 'nmap-quick', name: 'Network Asset Discovery', endpoint: '/api/scan/quick', priority: 3 },
          { id: 'masscan', name: 'Large-Scale Port Discovery', endpoint: '/api/scan/masscan', priority: 4 }
        ]
      },
      {
        id: 'enumeration',
        title: 'Enumeration',
        order: 2,
        description: 'Detailed service and application enumeration',
        tools: [
          { id: 'nmap-service', name: 'Service Enumeration', endpoint: '/api/scan/service', priority: 1 },
          { id: 'nmap-scripts', name: 'Advanced Service Enumeration', endpoint: '/api/scan/nmap/scripts', priority: 2 },
          { id: 'udp-scan', name: 'UDP Service Enumeration', endpoint: '/api/scan/udp-scan', priority: 2 },
          { id: 'gobuster', name: 'Web Application Enumeration', endpoint: '/api/web/gobuster', priority: 3 },
          { id: 'http-headers', name: 'Web Server Enumeration', endpoint: '/api/web/headers', priority: 3 },
          { id: 'ssl-analysis', name: 'SSL/TLS Service Analysis', endpoint: '/api/web/ssl', priority: 4 }
        ]
      },
      {
        id: 'vulnerability-assessment',
        title: 'Vulnerability Assessment',
        order: 3,
        description: 'Identify and validate security weaknesses',
        tools: [
          { id: 'nuclei', name: 'Comprehensive Vulnerability Assessment', endpoint: '/api/exploit/nuclei', priority: 1 },
          { id: 'nmap-vulners', name: 'Network Vulnerability Scanning', endpoint: '/api/scan/nmap/vulners', priority: 1 },
          { id: 'nikto', name: 'Web Application Vulnerability Assessment', endpoint: '/api/web/nikto', priority: 2 },
          { id: 'wapiti', name: 'Advanced Web Vulnerability Scanning', endpoint: '/api/web/wapiti', priority: 2 },
          { id: 'zap-baseline', name: 'Security Baseline Assessment', endpoint: '/api/web/zap-baseline', priority: 3 },
          { id: 'xss-test', name: 'Input Validation Testing', endpoint: '/api/web/xss', priority: 3 },
          { id: 'sql-injection', name: 'Database Injection Testing', endpoint: '/api/exploit/sqlmap', priority: 4 }
        ]
      },
      {
        id: 'reporting',
        title: 'Reporting Phase',
        order: 4,
        description: 'Document findings according to NIST guidelines',
        tools: []
      }
    ]
  },
  
  sans: {
    id: 'sans',
    name: 'SANS Penetration Testing',
    description: 'SANS Institute penetration testing methodology',
    phases: [
      {
        id: 'target-input',
        title: 'Reconnaissance',
        order: 0,
        description: 'Passive and active information gathering',
        tools: []
      },
      {
        id: 'scanning',
        title: 'Scanning & Enumeration',
        order: 1,
        description: 'Network scanning and service enumeration',
        tools: [
          { id: 'whois', name: 'Target Reconnaissance', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Reconnaissance', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Advanced Subdomain Enumeration', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'subfinder', name: 'Passive Subdomain Discovery', endpoint: '/api/recon/subfinder', priority: 2 },
          { id: 'assetfinder', name: 'Asset Discovery', endpoint: '/api/recon/assetfinder', priority: 3 },
          { id: 'theharvester', name: 'Email and Host Discovery', endpoint: '/api/recon/theharvester', priority: 3 },
          { id: 'nmap-quick', name: 'Port Scanning', endpoint: '/api/scan/quick', priority: 4 },
          { id: 'masscan', name: 'High-Speed Port Scanning', endpoint: '/api/scan/masscan', priority: 4 },
          { id: 'nmap-service', name: 'Service Detection', endpoint: '/api/scan/service', priority: 5 }
        ]
      },
      {
        id: 'vulnerability-identification',
        title: 'Vulnerability Identification',
        order: 2,
        description: 'Identify potential security vulnerabilities',
        tools: [
          { id: 'nuclei', name: 'Automated Vulnerability Discovery', endpoint: '/api/exploit/nuclei', priority: 1 },
          { id: 'nmap-vulners', name: 'Network Vulnerability Scanning', endpoint: '/api/scan/nmap/vulners', priority: 1 },
          { id: 'http-headers', name: 'Web Server Analysis', endpoint: '/api/web/headers', priority: 2 },
          { id: 'ssl-analysis', name: 'SSL/TLS Vulnerability Check', endpoint: '/api/web/ssl', priority: 2 },
          { id: 'nikto', name: 'Web Vulnerability Scanning', endpoint: '/api/web/nikto', priority: 3 },
          { id: 'wapiti', name: 'Advanced Web Application Testing', endpoint: '/api/web/wapiti', priority: 3 },
          { id: 'gobuster', name: 'Content Discovery', endpoint: '/api/web/gobuster', priority: 4 },
          { id: 'ffuf', name: 'Parameter and Path Fuzzing', endpoint: '/api/web/ffuf', priority: 4 }
        ]
      },
      {
        id: 'exploitation',
        title: 'Exploitation',
        order: 3,
        description: 'Attempt to exploit identified vulnerabilities',
        tools: [
          { id: 'zap-baseline', name: 'Security Baseline Validation', endpoint: '/api/web/zap-baseline', priority: 1 },
          { id: 'xss-test', name: 'Cross-Site Scripting Exploitation', endpoint: '/api/web/xss', priority: 2 },
          { id: 'sql-injection', name: 'SQL Injection Exploitation', endpoint: '/api/exploit/sqlmap', priority: 2 },
          { id: 'hydra', name: 'Password Attack', endpoint: '/api/exploit/hydra', priority: 3 },
          { id: 'metasploit', name: 'Metasploit Exploitation Framework', endpoint: '/api/exploit/metasploit', priority: 4 },
          { id: 'john', name: 'Password Cracking', endpoint: '/api/exploit/john', priority: 5 }
        ]
      },
      {
        id: 'reporting',
        title: 'Reporting',
        order: 4,
        description: 'Document findings and provide remediation guidance',
        tools: []
      }
    ]
  }
};

export const SimplePentestProvider = ({ children }) => {
  const [wizardState, setWizardState] = useState({
    currentPhase: 'framework-selection',
    selectedFramework: null,
    target: '',
    targetType: 'domain',
    isRunning: false,
    completedPhases: [],
    phaseData: {},
    findings: [],
    startTime: null,
    endTime: null
  });

  const [executionState, setExecutionState] = useState({
    selectedTools: {},
    results: {},
    activities: [],
    terminalOutput: '',
    isExecuting: false,
    currentTool: null,
    toolOutput: '',
    toolProgress: 0,
    isToolRunning: false
  });

  // Add state for automatic report display
  const [showReportModal, setShowReportModal] = useState(false);
  const [completedReport, setCompletedReport] = useState(null);

  // Select framework
  const selectFramework = (frameworkId) => {
    const framework = FRAMEWORKS[frameworkId];
    if (!framework) {
      toast.error('Invalid framework selected');
      return;
    }

    setWizardState(prev => ({
      ...prev,
      selectedFramework: framework,
      currentPhase: 'target-input',
      completedPhases: [],
      phaseData: {},
      findings: []
    }));

    setExecutionState(prev => ({
      ...prev,
      activities: [{
        type: 'info',
        message: `Selected ${framework.name} methodology`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));

    toast.success(`${framework.name} methodology selected`);
  };

  // Initialize wizard with target
  const startWizard = (target, targetType = 'domain') => {
    if (!wizardState.selectedFramework) {
      toast.error('Please select a security framework first');
      return;
    }

    const startTime = new Date().toISOString();
    const firstPhase = wizardState.selectedFramework.phases.find(p => p.order === 1);
    
    setWizardState(prev => ({
      ...prev,
      target,
      targetType,
      startTime,
      currentPhase: firstPhase?.id || 'intelligence-gathering',
      completedPhases: ['target-input'],
      phaseData: {
        'target-input': { 
          target, 
          targetType, 
          framework: prev.selectedFramework.id,
          timestamp: startTime 
        }
      }
    }));

    setExecutionState(prev => ({
      ...prev,
      activities: [...prev.activities, {
        type: 'info',
        message: `Assessment started for ${target} using ${wizardState.selectedFramework.name}`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));

    toast.success(`Assessment started for ${target}`);
  };

  // Select/deselect tools for current phase
  const toggleTool = (toolId) => {
    setExecutionState(prev => ({
      ...prev,
      selectedTools: {
        ...prev.selectedTools,
        [toolId]: !prev.selectedTools[toolId]
      }
    }));
  };

  // Auto-select tools based on framework priority
  const autoSelectToolsByPriority = () => {
    if (!wizardState.selectedFramework) return;
    
    const currentPhaseData = wizardState.selectedFramework.phases.find(p => p.id === wizardState.currentPhase);
    if (!currentPhaseData?.tools) return;

    // Sort tools by priority and select them
    const sortedTools = [...currentPhaseData.tools].sort((a, b) => (a.priority || 999) - (b.priority || 999));
    const newSelectedTools = {};
    
    sortedTools.forEach(tool => {
      newSelectedTools[tool.id] = true;
    });

    setExecutionState(prev => ({
      ...prev,
      selectedTools: newSelectedTools,
      activities: [...prev.activities, {
        type: 'info',
        message: `Auto-selected ${sortedTools.length} tools in prescribed order`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));
  };

  // Execute selected tools for current phase
  const executePhase = async () => {
    if (!wizardState.selectedFramework) {
      toast.error('No framework selected');
      return;
    }

    const currentPhaseData = wizardState.selectedFramework.phases.find(p => p.id === wizardState.currentPhase);
    const selectedToolIds = Object.keys(executionState.selectedTools).filter(
      toolId => executionState.selectedTools[toolId]
    );

    if (selectedToolIds.length === 0) {
      toast.error('Please select at least one tool to execute');
      return;
    }

    setExecutionState(prev => ({ 
      ...prev, 
      isExecuting: true, 
      isToolRunning: true, 
      terminalOutput: '', 
      toolOutput: '', 
      toolProgress: 0,
      activities: [...prev.activities, {
        type: 'info',
        message: `Starting ${currentPhaseData.title} phase (${wizardState.selectedFramework.name})`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));
    
    const phaseResults = {
      phase: currentPhaseData.id,
      framework: wizardState.selectedFramework.id,
      tools: [],
      findings: [],
      timestamp: new Date().toISOString()
    };

    try {
      // Sort tools by priority for execution order
      const toolsToExecute = selectedToolIds.map(toolId => {
        return currentPhaseData.tools.find(t => t.id === toolId);
      }).filter(Boolean).sort((a, b) => (a.priority || 999) - (b.priority || 999));

      for (let i = 0; i < toolsToExecute.length; i++) {
        const tool = toolsToExecute[i];
        
        if (!tool) continue;

        setExecutionState(prev => ({
          ...prev,
          currentTool: tool.name,
          toolProgress: Math.round(((i + 0.5) / toolsToExecute.length) * 100),
          activities: [...prev.activities, {
            type: 'info',
            message: `Executing ${tool.name} (priority ${tool.priority || 'N/A'})`,
            timestamp: new Date().toLocaleTimeString()
          }]
        }));

        try {
          // Prepare request body
          let requestBody = { target: wizardState.target };
          
          if (tool.endpoint.includes('/web/')) {
            if (wizardState.targetType === 'domain') {
              requestBody.target = `https://${wizardState.target}`;
            } else {
              requestBody.target = `http://${wizardState.target}`;
            }
          }

          const response = await fetch(`http://localhost:3001${tool.endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const result = await response.json();
          const output = result.output || result.data || JSON.stringify(result.result, null, 2) || 'Tool executed successfully';

          setExecutionState(prev => ({
            ...prev,
            terminalOutput: prev.terminalOutput + `\n=== ${tool.name} (Priority ${tool.priority}) ===\n${output}\n`,
            toolOutput: prev.toolOutput + `\n=== ${tool.name} ===\n${output}\n`,
            results: {
              ...prev.results,
              [tool.id]: { success: result.success !== false, output, timestamp: new Date(), priority: tool.priority }
            },
            activities: [...prev.activities, {
              type: 'success',
              message: `${tool.name} completed successfully`,
              timestamp: new Date().toLocaleTimeString()
            }]
          }));

          phaseResults.tools.push({
            id: tool.id,
            name: tool.name,
            priority: tool.priority,
            success: result.success !== false,
            output: output,
            findings: result.findings || [],
            metadata: result.metadata || {}
          });

          if (result.findings && result.findings.length > 0) {
            phaseResults.findings.push(...result.findings);
          }

        } catch (error) {
          console.error(`Tool ${tool.name} failed:`, error);
          
          let errorMessage = error.message || 'Tool execution failed';

          setExecutionState(prev => ({
            ...prev,
            terminalOutput: prev.terminalOutput + `\n=== ${tool.name} (Priority ${tool.priority}) ===\nERROR: ${errorMessage}\n`,
            toolOutput: prev.toolOutput + `\n=== ${tool.name} ===\nERROR: ${errorMessage}\n`,
            results: {
              ...prev.results,
              [tool.id]: { success: false, output: `Error: ${errorMessage}`, timestamp: new Date(), priority: tool.priority }
            },
            activities: [...prev.activities, {
              type: 'error',
              message: `${tool.name} failed: ${errorMessage}`,
              timestamp: new Date().toLocaleTimeString()
            }]
          }));

          phaseResults.tools.push({
            id: tool.id,
            name: tool.name,
            priority: tool.priority,
            success: false,
            output: `Error: ${errorMessage}`,
            findings: [],
            metadata: {}
          });
        }

        setExecutionState(prev => ({
          ...prev,
          toolProgress: Math.round(((i + 1) / toolsToExecute.length) * 100)
        }));
      }

      // Complete phase
      setWizardState(prev => ({
        ...prev,
        completedPhases: [...prev.completedPhases, prev.currentPhase],
        phaseData: {
          ...prev.phaseData,
          [prev.currentPhase]: phaseResults
        },
        findings: [...prev.findings, ...phaseResults.findings]
      }));

      setExecutionState(prev => ({
        ...prev,
        currentTool: null,
        isExecuting: false,
        isToolRunning: false,
        selectedTools: {},
        activities: [...prev.activities, {
          type: 'success',
          message: `${currentPhaseData.title} phase completed using ${wizardState.selectedFramework.name} methodology`,
          timestamp: new Date().toLocaleTimeString()
        }]
      }));

      const successfulTools = phaseResults.tools.filter(t => t.success).length;
      const totalTools = phaseResults.tools.length;
      
      if (successfulTools === totalTools) {
        toast.success(`${currentPhaseData.title} completed successfully (${successfulTools}/${totalTools} tools)`);
      } else if (successfulTools > 0) {
        toast.success(`${currentPhaseData.title} completed with ${successfulTools}/${totalTools} tools successful`);
      } else {
        toast.error(`${currentPhaseData.title} completed with errors`);
      }

      // Add guidance toast after a brief delay
      setTimeout(() => {
        toast.success(`🎉 ${currentPhaseData.title} phase complete! Click "Next Phase" to continue.`, {
          duration: 5000,
          icon: '👆'
        });
      }, 1500);

    } catch (error) {
      console.error('Phase execution error:', error);
      toast.error(`Error executing phase: ${error.message}`);
      setExecutionState(prev => ({ 
        ...prev, 
        isToolRunning: false, 
        currentTool: null,
        toolOutput: prev.toolOutput + `\nPhase execution failed: ${error.message}\n`
      }));
    }
  };

  // Enhanced nextPhase function to automatically show report
  const nextPhase = () => {
    if (!wizardState.selectedFramework) return;
    
    const currentPhaseIndex = wizardState.selectedFramework.phases.findIndex(p => p.id === wizardState.currentPhase);
    if (currentPhaseIndex < wizardState.selectedFramework.phases.length - 1) {
      const nextPhase = wizardState.selectedFramework.phases[currentPhaseIndex + 1];
      setWizardState(prev => ({
        ...prev,
        currentPhase: nextPhase.id
      }));
      setExecutionState(prev => ({ 
        ...prev, 
        toolOutput: '',
        terminalOutput: '',
        selectedTools: {},
        activities: [...prev.activities, {
          type: 'info',
          message: `Moving to ${nextPhase.title} phase`,
          timestamp: new Date().toLocaleTimeString()
        }]
      }));
    } else {
      // Assessment complete - automatically generate and show report
      const finalReport = generateReport();
      setCompletedReport(finalReport);
      setShowReportModal(true);
      setExecutionState(prev => ({ 
        ...prev, 
        activities: [...prev.activities, {
          type: 'success',
          message: '🎉 Assessment complete! Report generated successfully.',
          timestamp: new Date().toLocaleTimeString()
        }]
      }));
      toast.success('🎉 Assessment Complete! Professional report is ready for download.');
    }
  };

  // Reset wizard to initial state
  const resetWizard = () => {
    setWizardState({
      currentPhase: 'framework-selection',
      selectedFramework: null,
      target: '',
      targetType: 'domain',
      isRunning: false,
      completedPhases: [],
      phaseData: {},
      findings: [],
      startTime: null,
      endTime: null
    });
    setExecutionState({
      selectedTools: {},
      results: {},
      activities: [],
      terminalOutput: '',
      isExecuting: false,
      currentTool: null,
      toolOutput: '',
      toolProgress: 0,
      isToolRunning: false
    });
    toast.success('Wizard reset');
  };

  // Enhanced generateReport function with better formatting
  const generateReport = useCallback(() => {
    const endTime = new Date().toISOString();
    const duration = wizardState.startTime ? new Date(endTime) - new Date(wizardState.startTime) : 0;
    
    // Don't update state during report generation to prevent loops
    // setWizardState(prev => ({ ...prev, endTime }));

    // Get all tools and their results
    const allTools = [];
    const successfulTools = [];
    const failedTools = [];
    
    Object.entries(wizardState.phaseData).forEach(([phaseId, data]) => {
      if (data.tools) {
        data.tools.forEach(tool => {
          allTools.push(tool);
          if (tool.success) {
            successfulTools.push(tool);
          } else {
            failedTools.push(tool);
          }
        });
      }
    });

    // Extract security findings
    const openPorts = [];
    const services = [];
    const vulnerabilities = [];
    
    successfulTools.forEach(tool => {
      if (tool.result?.open_ports) {
        openPorts.push(...tool.result.open_ports);
      }
      if (tool.result?.services) {
        services.push(...tool.result.services);
      }
      if (tool.result?.vulnerabilities) {
        vulnerabilities.push(...tool.result.vulnerabilities);
      }
    });

    // Calculate risk assessment
    const calculateRiskLevel = () => {
      if (vulnerabilities.length > 5) return 'Critical';
      if (vulnerabilities.length > 2 || openPorts.length > 20) return 'High';
      if (vulnerabilities.length > 0 || openPorts.length > 10) return 'Medium';
      if (openPorts.length > 5) return 'Low';
      return 'Informational';
    };

    const report = {
      metadata: {
        reportId: `${wizardState.selectedFramework?.id || 'assessment'}-${Date.now()}`,
        title: `${wizardState.selectedFramework?.name || 'Security'} Assessment Report`,
        target: wizardState.target,
        targetType: wizardState.targetType,
        methodology: wizardState.selectedFramework?.name || 'Standard Framework',
        tester: 'HackNest Platform',
        generatedAt: endTime,
        version: '2.0'
      },
      
      framework: {
        id: wizardState.selectedFramework?.id,
        name: wizardState.selectedFramework?.name,
        description: wizardState.selectedFramework?.description,
        phases: wizardState.selectedFramework?.phases || []
      },
      
      executiveSummary: {
        target: wizardState.target,
        targetType: wizardState.targetType,
        testDate: wizardState.startTime ? new Date(wizardState.startTime).toLocaleDateString() : new Date().toLocaleDateString(),
        testTime: wizardState.startTime ? new Date(wizardState.startTime).toLocaleTimeString() : new Date().toLocaleTimeString(),
        duration: Math.round(duration / 1000) + ' seconds',
        methodology: wizardState.selectedFramework?.name || 'Unknown',
        overallRisk: calculateRiskLevel(),
        keyFindings: {
          totalFindings: vulnerabilities.length,
          openPorts: [...new Set(openPorts.map(p => p.port))].length,
          identifiedServices: [...new Set(services.map(s => s.service))].length,
          vulnerabilities: vulnerabilities.length,
          toolFailures: failedTools.length,
          successRate: Math.round((successfulTools.length / Math.max(allTools.length, 1)) * 100)
        },
        recommendations: [
          vulnerabilities.length > 0 ? `Address ${vulnerabilities.length} identified vulnerabilities` : null,
          openPorts.length > 10 ? 'Review and close unnecessary open ports' : null,
          failedTools.length > 0 ? 'Fix tool integration issues for complete assessment' : null,
          'Implement regular security scanning per ' + (wizardState.selectedFramework?.name || 'industry standards'),
          'Consider follow-up testing with additional ' + (wizardState.selectedFramework?.name || 'framework') + ' phases'
        ].filter(Boolean)
      },
      
      technicalDetails: {
        target: wizardState.target,
        targetType: wizardState.targetType,
        startTime: wizardState.startTime,
        endTime,
        duration,
        phasesCompleted: wizardState.completedPhases.length,
        totalPhases: wizardState.selectedFramework?.phases?.length || 0
      },
      
      phases: Object.entries(wizardState.phaseData).map(([phaseId, data]) => ({
        ...data,
        phaseName: wizardState.selectedFramework?.phases.find(p => p.id === phaseId)?.title || `Phase ${phaseId}`,
        phaseOrder: wizardState.selectedFramework?.phases.find(p => p.id === phaseId)?.order || 0,
        description: wizardState.selectedFramework?.phases.find(p => p.id === phaseId)?.description || ''
      })).sort((a, b) => a.phaseOrder - b.phaseOrder),
      
      findings: {
        total: vulnerabilities.length,
        vulnerabilities: vulnerabilities,
        userFindings: wizardState.findings || []
      },
      
      summary: {
        totalPhases: wizardState.completedPhases.length,
        totalTools: allTools.length,
        successfulTools: successfulTools.length,
        failedTools: failedTools.length,
        successRate: Math.round((successfulTools.length / Math.max(allTools.length, 1)) * 100),
        riskLevel: calculateRiskLevel()
      },
      
      discoveredAssets: {
        openPorts: [...new Set(openPorts.map(p => ({ port: p.port, service: p.service, state: p.state })))].slice(0, 50),
        services: [...new Set(services.map(s => s.service))].slice(0, 20),
        ipAddresses: [...new Set(openPorts.map(p => p.ip).filter(Boolean))].slice(0, 10)
      },
      
      rawData: {
        phaseData: wizardState.phaseData,
        toolResults: executionState.results,
        activities: executionState.activities
      }
    };

    return report;
  }, [wizardState, executionState]);

  // Function to export report in multiple formats
  const exportReport = (report, format = 'html') => {
    const timestamp = new Date().toISOString().split('T')[0];
    const frameworkName = report.framework?.name?.toLowerCase().replace(/\s+/g, '-') || 'security';
    const fileName = `${frameworkName}-assessment-${report.metadata.target}-${timestamp}`;

    if (format === 'json') {
      const dataStr = JSON.stringify(report, null, 2);
      const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
      
      const linkElement = document.createElement('a');
      linkElement.setAttribute('href', dataUri);
      linkElement.setAttribute('download', `${fileName}.json`);
      linkElement.click();
      
      toast.success('📄 JSON report downloaded successfully!');
    } else if (format === 'html') {
      const htmlContent = generateHTMLReport(report);
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      
      const linkElement = document.createElement('a');
      linkElement.href = url;
      linkElement.download = `${fileName}.html`;
      linkElement.click();
      
      URL.revokeObjectURL(url);
      toast.success('📊 Professional HTML report downloaded successfully!');
    }
  };

  // Enhanced HTML report generator
  const generateHTMLReport = (report) => {
    const riskColorMap = {
      'Critical': '#dc2626',
      'High': '#ea580c', 
      'Medium': '#ca8a04',
      'Low': '#16a34a',
      'Informational': '#2563eb'
    };

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${report.metadata.title}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background: #f8fafc; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #1e40af 0%, #7c3aed 100%); color: white; padding: 40px; border-radius: 10px; margin-bottom: 30px; text-align: center; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header .subtitle { font-size: 1.2em; opacity: 0.9; }
        .metadata { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }
        .metadata-item { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .metadata-item h3 { color: #1e40af; margin-bottom: 10px; }
        .section { background: white; margin: 20px 0; padding: 30px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.07); }
        .section h2 { color: #1e40af; border-bottom: 3px solid #3b82f6; padding-bottom: 10px; margin-bottom: 20px; }
        .risk-badge { display: inline-block; padding: 8px 16px; border-radius: 20px; color: white; font-weight: bold; font-size: 0.9em; }
        .findings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .finding-card { background: #f1f5f9; padding: 15px; border-radius: 8px; border-left: 4px solid #3b82f6; }
        .phase-item { background: #f8fafc; padding: 20px; margin: 15px 0; border-radius: 8px; border: 1px solid #e2e8f0; }
        .phase-item h3 { color: #1e40af; margin-bottom: 10px; }
        .tool-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 10px; margin: 10px 0; }
        .tool-item { background: white; padding: 10px; border-radius: 6px; border: 1px solid #e2e8f0; display: flex; align-items: center; justify-content: between; }
        .tool-success { border-left: 4px solid #16a34a; }
        .tool-failed { border-left: 4px solid #dc2626; }
        .progress-bar { background: #e2e8f0; height: 10px; border-radius: 5px; overflow: hidden; }
        .progress-fill { background: linear-gradient(90deg, #16a34a 0%, #3b82f6 100%); height: 100%; transition: width 0.3s ease; }
        .footer { text-align: center; padding: 30px; color: #64748b; border-top: 2px solid #e2e8f0; margin-top: 40px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; }
        th { background: #f1f5f9; color: #1e40af; font-weight: 600; }
        .highlight { background: #fef3c7; padding: 2px 6px; border-radius: 4px; }
        @media print { body { background: white; } .section { box-shadow: none; border: 1px solid #ddd; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🛡️ ${report.metadata.title}</h1>
            <div class="subtitle">Comprehensive Security Assessment Report</div>
            <div style="margin-top: 20px; font-size: 1em;">
                Target: <span class="highlight">${report.metadata.target}</span> • 
                Framework: <span class="highlight">${report.framework.name}</span>
            </div>
        </div>

        <div class="metadata">
            <div class="metadata-item">
                <h3>📋 Assessment Details</h3>
                <p><strong>Target:</strong> ${report.metadata.target}</p>
                <p><strong>Type:</strong> ${report.metadata.targetType}</p>
                <p><strong>Date:</strong> ${report.executiveSummary.testDate}</p>
                <p><strong>Time:</strong> ${report.executiveSummary.testTime}</p>
                <p><strong>Duration:</strong> ${report.executiveSummary.duration}</p>
            </div>
            <div class="metadata-item">
                <h3>🎯 Methodology</h3>
                <p><strong>Framework:</strong> ${report.framework.name}</p>
                <p><strong>Phases:</strong> ${report.technicalDetails.phasesCompleted}/${report.technicalDetails.totalPhases}</p>
                <p><strong>Success Rate:</strong> ${report.summary.successRate}%</p>
            </div>
            <div class="metadata-item">
                <h3>⚡ Risk Assessment</h3>
                <p><strong>Overall Risk:</strong> 
                    <span class="risk-badge" style="background-color: ${riskColorMap[report.executiveSummary.overallRisk] || '#6b7280'}">
                        ${report.executiveSummary.overallRisk}
                    </span>
                </p>
                <p><strong>Findings:</strong> ${report.findings.total}</p>
                <p><strong>Open Ports:</strong> ${report.executiveSummary.keyFindings.openPorts}</p>
            </div>
        </div>

        <div class="section">
            <h2>📊 Executive Summary</h2>
            <p>This ${report.framework.name} security assessment was conducted against <strong>${report.metadata.target}</strong> 
               on ${report.executiveSummary.testDate} using industry-standard penetration testing methodology.</p>
            
            <div class="findings-grid">
                <div class="finding-card">
                    <h4>🔍 Total Findings</h4>
                    <p style="font-size: 2em; color: #1e40af; font-weight: bold;">${report.findings.total}</p>
                </div>
                <div class="finding-card">
                    <h4>🚪 Open Ports</h4>
                    <p style="font-size: 2em; color: #7c3aed; font-weight: bold;">${report.executiveSummary.keyFindings.openPorts}</p>
                </div>
                <div class="finding-card">
                    <h4>⚙️ Services</h4>
                    <p style="font-size: 2em; color: #059669; font-weight: bold;">${report.executiveSummary.keyFindings.identifiedServices}</p>
                </div>
                <div class="finding-card">
                    <h4>✅ Success Rate</h4>
                    <p style="font-size: 2em; color: #dc2626; font-weight: bold;">${report.summary.successRate}%</p>
                </div>
            </div>

            <h3>🎯 Key Recommendations</h3>
            <ul style="margin: 15px 0; padding-left: 20px;">
                ${report.executiveSummary.recommendations.map(rec => `<li style="margin: 8px 0;">${rec}</li>`).join('')}
            </ul>
        </div>

        <div class="section">
            <h2>🔄 Testing Phases</h2>
            <div class="progress-bar" style="margin: 20px 0;">
                <div class="progress-fill" style="width: ${(report.technicalDetails.phasesCompleted / report.technicalDetails.totalPhases) * 100}%"></div>
            </div>
            <p style="text-align: center; margin: 10px 0; color: #64748b;">
                Progress: ${report.technicalDetails.phasesCompleted} of ${report.technicalDetails.totalPhases} phases completed
            </p>

            ${report.phases.map(phase => `
                <div class="phase-item">
                    <h3>📋 ${phase.phaseName}</h3>
                    <p style="color: #64748b; margin-bottom: 15px;">${phase.description || 'Testing phase execution'}</p>
                    <p><strong>Tools Executed:</strong> ${phase.tools ? phase.tools.length : 0}</p>
                    
                    ${phase.tools && phase.tools.length > 0 ? `
                        <div class="tool-list">
                            ${phase.tools.map(tool => `
                                <div class="tool-item ${tool.success ? 'tool-success' : 'tool-failed'}">
                                    <span style="flex: 1;">${tool.name}</span>
                                    <span style="color: ${tool.success ? '#16a34a' : '#dc2626'}; font-weight: bold;">
                                        ${tool.success ? '✅ Success' : '❌ Failed'}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    ` : '<p style="color: #64748b; font-style: italic;">No tools executed in this phase</p>'}
                </div>
            `).join('')}
        </div>

        ${report.discoveredAssets.openPorts.length > 0 ? `
        <div class="section">
            <h2>🚪 Discovered Open Ports</h2>
            <table>
                <thead>
                    <tr>
                        <th>Port</th>
                        <th>Service</th>
                        <th>State</th>
                    </tr>
                </thead>
                <tbody>
                    ${report.discoveredAssets.openPorts.slice(0, 20).map(port => `
                        <tr>
                            <td><strong>${port.port}</strong></td>
                            <td>${port.service || 'Unknown'}</td>
                            <td><span style="color: ${port.state === 'open' ? '#16a34a' : '#dc2626'}">${port.state}</span></td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
            ${report.discoveredAssets.openPorts.length > 20 ? '<p style="color: #64748b; font-style: italic;">Showing first 20 ports. See raw data for complete list.</p>' : ''}
        </div>
        ` : ''}

        <div class="section">
            <h2>📈 Assessment Statistics</h2>
            <div class="findings-grid">
                <div class="finding-card">
                    <h4>📊 Tools Statistics</h4>
                    <p>Total Tools: <strong>${report.summary.totalTools}</strong></p>
                    <p>Successful: <strong style="color: #16a34a;">${report.summary.successfulTools}</strong></p>
                    <p>Failed: <strong style="color: #dc2626;">${report.summary.failedTools}</strong></p>
                </div>
                <div class="finding-card">
                    <h4>⏱️ Timing Information</h4>
                    <p>Start: <strong>${new Date(report.technicalDetails.startTime).toLocaleString()}</strong></p>
                    <p>End: <strong>${new Date(report.technicalDetails.endTime).toLocaleString()}</strong></p>
                    <p>Duration: <strong>${report.technicalDetails.duration}</strong></p>
                </div>
            </div>
        </div>

        <div class="footer">
            <p><strong>Report Generated by HackNest Penetration Testing Platform</strong></p>
            <p>Framework: ${report.framework.name} • Report ID: ${report.metadata.reportId}</p>
            <p>Generated on: ${new Date(report.metadata.generatedAt).toLocaleString()}</p>
            <p style="margin-top: 15px; font-size: 0.9em; color: #94a3b8;">
                This report contains confidential security information and should be handled according to your organization's data classification policies.
            </p>
        </div>
    </div>
</body>
</html>`;
  };

  // Computed values
  const currentPhaseData = wizardState.selectedFramework?.phases.find(p => p.id === wizardState.currentPhase);
  const phases = wizardState.selectedFramework?.phases || [];
  const frameworks = FRAMEWORKS;
  
  const totalPhases = phases.length - 1;
  const completedCount = wizardState.completedPhases.filter(p => p !== 'target-input').length;
  const progressPercentage = Math.round((completedCount / totalPhases) * 100);

  // Check if phase is complete
  const isPhaseComplete = (phaseId) => {
    return wizardState.completedPhases.includes(phaseId);
  };

  // Check if can proceed to next phase
  const canProceed = () => {
    if (wizardState.currentPhase === 'target-input') {
      return wizardState.target.length > 0;
    }
    return isPhaseComplete(wizardState.currentPhase);
  };

  // Check if wizard is complete
  const isWizardComplete = () => {
    return wizardState.currentPhase === 'reporting' || 
           wizardState.completedPhases.includes('reporting');
  };

  const value = {
    // State
    wizardState,
    executionState,
    
    // Computed values
    currentPhaseData,
    phases,
    frameworks,
    progressPercentage,
    
    // Actions
    selectFramework,
    startWizard,
    toggleTool,
    autoSelectToolsByPriority,
    executePhase,
    nextPhase,
    resetWizard,
    generateReport,
    exportReport,
    generateHTMLReport,
    
    // Helpers
    isPhaseComplete,
    canProceed,
    isWizardComplete,
    
    // New state
    showReportModal,
    setShowReportModal,
    completedReport,
    setCompletedReport
  };

  return (
    <SimplePentestContext.Provider value={value}>
      {children}
    </SimplePentestContext.Provider>
  );
};

export const useSimplePentest = () => {
  const context = useContext(SimplePentestContext);
  if (!context) {
    throw new Error('useSimplePentest must be used within a SimplePentestProvider');
  }
  return context;
}; 