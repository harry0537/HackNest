import React, { createContext, useContext, useState } from 'react';
import toast from 'react-hot-toast';

const SimplePentestContext = createContext();

// Security Testing Frameworks with prescribed methodologies
const FRAMEWORKS = {
  ptes: {
    id: 'ptes',
    name: 'PTES (Penetration Testing Execution Standard)',
    description: 'Comprehensive penetration testing methodology with 5 phases',
    phases: [
      {
        id: 'target-input',
        title: 'Pre-Engagement & Target Input',
        order: 0,
        description: 'Initial target information and scope definition',
        tools: []
      },
      {
        id: 'intelligence-gathering',
        title: 'Intelligence Gathering',
        order: 1,
        description: 'Active and passive information collection',
        tools: [
          { id: 'whois', name: 'WHOIS Information Gathering', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Information Gathering', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Amass Subdomain Enumeration', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'subfinder', name: 'Subfinder Subdomain Discovery', endpoint: '/api/recon/subfinder', priority: 2 },
          { id: 'assetfinder', name: 'Assetfinder Asset Discovery', endpoint: '/api/recon/assetfinder', priority: 3 },
          { id: 'theharvester', name: 'TheHarvester OSINT Gathering', endpoint: '/api/recon/theharvester', priority: 3 },
          { id: 'subdomain', name: 'Subdomain Enumeration', endpoint: '/api/recon/subdomains', priority: 4 }
        ]
      },
      {
        id: 'threat-modeling',
        title: 'Threat Modeling & Vulnerability Analysis',
        order: 2,
        description: 'Network discovery and service enumeration',
        tools: [
          { id: 'nmap-quick', name: 'Network Discovery Scan', endpoint: '/api/scan/quick', priority: 1 },
          { id: 'masscan', name: 'Masscan Fast Port Scan', endpoint: '/api/scan/masscan', priority: 1 },
          { id: 'nmap-service', name: 'Service Version Detection', endpoint: '/api/scan/service', priority: 2 },
          { id: 'nmap-scripts', name: 'Nmap Script Scanning', endpoint: '/api/scan/nmap/scripts', priority: 3 },
          { id: 'nmap-vulners', name: 'Nmap Vulnerability Scanning', endpoint: '/api/scan/nmap/vulners', priority: 3 },
          { id: 'udp-scan', name: 'UDP Port Scanning', endpoint: '/api/scan/udp-scan', priority: 4 },
          { id: 'nuclei', name: 'Nuclei Vulnerability Scanner', endpoint: '/api/exploit/nuclei', priority: 4 }
        ]
      },
      {
        id: 'exploitation',
        title: 'Exploitation',
        order: 3,
        description: 'Vulnerability exploitation and payload delivery',
        tools: [
          { id: 'http-headers', name: 'HTTP Security Headers Analysis', endpoint: '/api/web/headers', priority: 1 },
          { id: 'ssl-analysis', name: 'SSL/TLS Configuration Review', endpoint: '/api/web/ssl', priority: 1 },
          { id: 'nikto', name: 'Nikto Web Vulnerability Scanner', endpoint: '/api/web/nikto', priority: 2 },
          { id: 'gobuster', name: 'Gobuster Directory Enumeration', endpoint: '/api/web/gobuster', priority: 2 },
          { id: 'wapiti', name: 'Wapiti Web Vulnerability Scanner', endpoint: '/api/web/wapiti', priority: 3 },
          { id: 'zap-baseline', name: 'OWASP ZAP Baseline Scan', endpoint: '/api/web/zap-baseline', priority: 3 },
          { id: 'ffuf', name: 'FFuF Web Fuzzer', endpoint: '/api/web/ffuf', priority: 4 },
          { id: 'xss-test', name: 'Cross-Site Scripting (XSS) Test', endpoint: '/api/web/xss', priority: 4 },
          { id: 'sql-injection', name: 'SQL Injection Assessment', endpoint: '/api/exploit/sqlmap', priority: 5 },
          { id: 'hydra', name: 'Hydra Password Attack', endpoint: '/api/exploit/hydra', priority: 5 },
          { id: 'metasploit', name: 'Metasploit Exploitation', endpoint: '/api/exploit/metasploit', priority: 6 }
        ]
      },
      {
        id: 'post-exploitation',
        title: 'Post-Exploitation & Reporting',
        order: 4,
        description: 'Privilege escalation, data exfiltration, and comprehensive reporting',
        tools: [
          { id: 'john', name: 'John the Ripper Password Cracking', endpoint: '/api/exploit/john', priority: 1 }
        ]
      }
    ]
  },
  
  owasp: {
    id: 'owasp',
    name: 'OWASP Testing Guide v4.2',
    description: 'Web application security testing methodology',
    phases: [
      {
        id: 'target-input',
        title: 'Information Gathering',
        order: 0,
        description: 'Collect preliminary information about the target',
        tools: []
      },
      {
        id: 'fingerprinting',
        title: 'Fingerprinting Web Server & Applications',
        order: 1,
        description: 'Identify web server, technologies, and frameworks',
        tools: [
          { id: 'whois', name: 'WHOIS Information', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Information', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Amass Subdomain Enumeration', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'subfinder', name: 'Subfinder Discovery', endpoint: '/api/recon/subfinder', priority: 2 },
          { id: 'http-headers', name: 'HTTP Headers Analysis', endpoint: '/api/web/headers', priority: 3 },
          { id: 'ssl-analysis', name: 'SSL/TLS Analysis', endpoint: '/api/web/ssl', priority: 3 },
          { id: 'theharvester', name: 'TheHarvester OSINT', endpoint: '/api/recon/theharvester', priority: 4 }
        ]
      },
      {
        id: 'configuration-testing',
        title: 'Configuration and Deployment Testing',
        order: 2,
        description: 'Test infrastructure and application configuration',
        tools: [
          { id: 'nmap-quick', name: 'Network Infrastructure Analysis', endpoint: '/api/scan/quick', priority: 1 },
          { id: 'nmap-service', name: 'Service Configuration Review', endpoint: '/api/scan/service', priority: 2 },
          { id: 'gobuster', name: 'File and Directory Enumeration', endpoint: '/api/web/gobuster', priority: 3 },
          { id: 'ffuf', name: 'Parameter and Content Discovery', endpoint: '/api/web/ffuf', priority: 4 },
          { id: 'nikto', name: 'Web Server Configuration Analysis', endpoint: '/api/web/nikto', priority: 4 }
        ]
      },
      {
        id: 'vulnerability-testing',
        title: 'Vulnerability Testing',
        order: 3,
        description: 'Test for common web application vulnerabilities',
        tools: [
          { id: 'nuclei', name: 'Automated Vulnerability Scan', endpoint: '/api/exploit/nuclei', priority: 1 },
          { id: 'wapiti', name: 'Comprehensive Web Vulnerability Scanner', endpoint: '/api/web/wapiti', priority: 2 },
          { id: 'zap-baseline', name: 'OWASP ZAP Security Baseline', endpoint: '/api/web/zap-baseline', priority: 2 },
          { id: 'xss-test', name: 'Cross-Site Scripting Testing', endpoint: '/api/web/xss', priority: 3 },
          { id: 'sql-injection', name: 'SQL Injection Testing', endpoint: '/api/exploit/sqlmap', priority: 3 },
          { id: 'nmap-vulners', name: 'Network Vulnerability Assessment', endpoint: '/api/scan/nmap/vulners', priority: 4 }
        ]
      },
      {
        id: 'reporting',
        title: 'Report Generation',
        order: 4,
        description: 'Compile findings into OWASP-compliant report',
        tools: []
      }
    ]
  },
  
  nist: {
    id: 'nist',
    name: 'NIST SP 800-115',
    description: 'Technical Guide to Information Security Testing and Assessment',
    phases: [
      {
        id: 'target-input',
        title: 'Planning',
        order: 0,
        description: 'Test planning and preparation phase',
        tools: []
      },
      {
        id: 'discovery',
        title: 'Discovery',
        order: 1,
        description: 'Network discovery and asset identification',
        tools: [
          { id: 'whois', name: 'Target Information Discovery', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Discovery', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Advanced Subdomain Discovery', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'assetfinder', name: 'Asset Discovery', endpoint: '/api/recon/assetfinder', priority: 2 },
          { id: 'theharvester', name: 'OSINT Information Gathering', endpoint: '/api/recon/theharvester', priority: 3 },
          { id: 'nmap-quick', name: 'Network Asset Discovery', endpoint: '/api/scan/quick', priority: 3 },
          { id: 'masscan', name: 'Large-Scale Port Discovery', endpoint: '/api/scan/masscan', priority: 4 }
        ]
      },
      {
        id: 'enumeration',
        title: 'Enumeration',
        order: 2,
        description: 'Detailed service and application enumeration',
        tools: [
          { id: 'nmap-service', name: 'Service Enumeration', endpoint: '/api/scan/service', priority: 1 },
          { id: 'nmap-scripts', name: 'Advanced Service Enumeration', endpoint: '/api/scan/nmap/scripts', priority: 2 },
          { id: 'udp-scan', name: 'UDP Service Enumeration', endpoint: '/api/scan/udp-scan', priority: 2 },
          { id: 'gobuster', name: 'Web Application Enumeration', endpoint: '/api/web/gobuster', priority: 3 },
          { id: 'http-headers', name: 'Web Server Enumeration', endpoint: '/api/web/headers', priority: 3 },
          { id: 'ssl-analysis', name: 'SSL/TLS Service Analysis', endpoint: '/api/web/ssl', priority: 4 }
        ]
      },
      {
        id: 'vulnerability-assessment',
        title: 'Vulnerability Assessment',
        order: 3,
        description: 'Identify and validate security weaknesses',
        tools: [
          { id: 'nuclei', name: 'Comprehensive Vulnerability Assessment', endpoint: '/api/exploit/nuclei', priority: 1 },
          { id: 'nmap-vulners', name: 'Network Vulnerability Scanning', endpoint: '/api/scan/nmap/vulners', priority: 1 },
          { id: 'nikto', name: 'Web Application Vulnerability Assessment', endpoint: '/api/web/nikto', priority: 2 },
          { id: 'wapiti', name: 'Advanced Web Vulnerability Scanning', endpoint: '/api/web/wapiti', priority: 2 },
          { id: 'zap-baseline', name: 'Security Baseline Assessment', endpoint: '/api/web/zap-baseline', priority: 3 },
          { id: 'xss-test', name: 'Input Validation Testing', endpoint: '/api/web/xss', priority: 3 },
          { id: 'sql-injection', name: 'Database Injection Testing', endpoint: '/api/exploit/sqlmap', priority: 4 }
        ]
      },
      {
        id: 'reporting',
        title: 'Reporting Phase',
        order: 4,
        description: 'Document findings according to NIST guidelines',
        tools: []
      }
    ]
  },
  
  sans: {
    id: 'sans',
    name: 'SANS Penetration Testing',
    description: 'SANS Institute penetration testing methodology',
    phases: [
      {
        id: 'target-input',
        title: 'Reconnaissance',
        order: 0,
        description: 'Passive and active information gathering',
        tools: []
      },
      {
        id: 'scanning',
        title: 'Scanning & Enumeration',
        order: 1,
        description: 'Network scanning and service enumeration',
        tools: [
          { id: 'whois', name: 'Target Reconnaissance', endpoint: '/api/recon/whois', priority: 1 },
          { id: 'dns', name: 'DNS Reconnaissance', endpoint: '/api/recon/dns', priority: 1 },
          { id: 'amass', name: 'Advanced Subdomain Enumeration', endpoint: '/api/recon/amass', priority: 2 },
          { id: 'subfinder', name: 'Passive Subdomain Discovery', endpoint: '/api/recon/subfinder', priority: 2 },
          { id: 'assetfinder', name: 'Asset Discovery', endpoint: '/api/recon/assetfinder', priority: 3 },
          { id: 'theharvester', name: 'Email and Host Discovery', endpoint: '/api/recon/theharvester', priority: 3 },
          { id: 'nmap-quick', name: 'Port Scanning', endpoint: '/api/scan/quick', priority: 4 },
          { id: 'masscan', name: 'High-Speed Port Scanning', endpoint: '/api/scan/masscan', priority: 4 },
          { id: 'nmap-service', name: 'Service Detection', endpoint: '/api/scan/service', priority: 5 }
        ]
      },
      {
        id: 'vulnerability-identification',
        title: 'Vulnerability Identification',
        order: 2,
        description: 'Identify potential security vulnerabilities',
        tools: [
          { id: 'nuclei', name: 'Automated Vulnerability Discovery', endpoint: '/api/exploit/nuclei', priority: 1 },
          { id: 'nmap-vulners', name: 'Network Vulnerability Scanning', endpoint: '/api/scan/nmap/vulners', priority: 1 },
          { id: 'http-headers', name: 'Web Server Analysis', endpoint: '/api/web/headers', priority: 2 },
          { id: 'ssl-analysis', name: 'SSL/TLS Vulnerability Check', endpoint: '/api/web/ssl', priority: 2 },
          { id: 'nikto', name: 'Web Vulnerability Scanning', endpoint: '/api/web/nikto', priority: 3 },
          { id: 'wapiti', name: 'Advanced Web Application Testing', endpoint: '/api/web/wapiti', priority: 3 },
          { id: 'gobuster', name: 'Content Discovery', endpoint: '/api/web/gobuster', priority: 4 },
          { id: 'ffuf', name: 'Parameter and Path Fuzzing', endpoint: '/api/web/ffuf', priority: 4 }
        ]
      },
      {
        id: 'exploitation',
        title: 'Exploitation',
        order: 3,
        description: 'Attempt to exploit identified vulnerabilities',
        tools: [
          { id: 'zap-baseline', name: 'Security Baseline Validation', endpoint: '/api/web/zap-baseline', priority: 1 },
          { id: 'xss-test', name: 'Cross-Site Scripting Exploitation', endpoint: '/api/web/xss', priority: 2 },
          { id: 'sql-injection', name: 'SQL Injection Exploitation', endpoint: '/api/exploit/sqlmap', priority: 2 },
          { id: 'hydra', name: 'Password Attack', endpoint: '/api/exploit/hydra', priority: 3 },
          { id: 'metasploit', name: 'Metasploit Exploitation Framework', endpoint: '/api/exploit/metasploit', priority: 4 },
          { id: 'john', name: 'Password Cracking', endpoint: '/api/exploit/john', priority: 5 }
        ]
      },
      {
        id: 'reporting',
        title: 'Reporting',
        order: 4,
        description: 'Document findings and provide remediation guidance',
        tools: []
      }
    ]
  }
};

export const SimplePentestProvider = ({ children }) => {
  const [wizardState, setWizardState] = useState({
    currentPhase: 'framework-selection',
    selectedFramework: null,
    target: '',
    targetType: 'domain',
    isRunning: false,
    completedPhases: [],
    phaseData: {},
    findings: [],
    startTime: null,
    endTime: null
  });

  const [executionState, setExecutionState] = useState({
    selectedTools: {},
    results: {},
    activities: [],
    terminalOutput: '',
    isExecuting: false,
    currentTool: null,
    toolOutput: '',
    toolProgress: 0,
    isToolRunning: false
  });

  // Select framework
  const selectFramework = (frameworkId) => {
    const framework = FRAMEWORKS[frameworkId];
    if (!framework) {
      toast.error('Invalid framework selected');
      return;
    }

    setWizardState(prev => ({
      ...prev,
      selectedFramework: framework,
      currentPhase: 'target-input',
      completedPhases: [],
      phaseData: {},
      findings: []
    }));

    setExecutionState(prev => ({
      ...prev,
      activities: [{
        type: 'info',
        message: `Selected ${framework.name} methodology`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));

    toast.success(`${framework.name} methodology selected`);
  };

  // Initialize wizard with target
  const startWizard = (target, targetType = 'domain') => {
    if (!wizardState.selectedFramework) {
      toast.error('Please select a security framework first');
      return;
    }

    const startTime = new Date().toISOString();
    const firstPhase = wizardState.selectedFramework.phases.find(p => p.order === 1);
    
    setWizardState(prev => ({
      ...prev,
      target,
      targetType,
      startTime,
      currentPhase: firstPhase?.id || 'intelligence-gathering',
      completedPhases: ['target-input'],
      phaseData: {
        'target-input': { 
          target, 
          targetType, 
          framework: prev.selectedFramework.id,
          timestamp: startTime 
        }
      }
    }));

    setExecutionState(prev => ({
      ...prev,
      activities: [...prev.activities, {
        type: 'info',
        message: `Assessment started for ${target} using ${wizardState.selectedFramework.name}`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));

    toast.success(`Assessment started for ${target}`);
  };

  // Select/deselect tools for current phase
  const toggleTool = (toolId) => {
    setExecutionState(prev => ({
      ...prev,
      selectedTools: {
        ...prev.selectedTools,
        [toolId]: !prev.selectedTools[toolId]
      }
    }));
  };

  // Auto-select tools based on framework priority
  const autoSelectToolsByPriority = () => {
    if (!wizardState.selectedFramework) return;
    
    const currentPhaseData = wizardState.selectedFramework.phases.find(p => p.id === wizardState.currentPhase);
    if (!currentPhaseData?.tools) return;

    // Sort tools by priority and select them
    const sortedTools = [...currentPhaseData.tools].sort((a, b) => (a.priority || 999) - (b.priority || 999));
    const newSelectedTools = {};
    
    sortedTools.forEach(tool => {
      newSelectedTools[tool.id] = true;
    });

    setExecutionState(prev => ({
      ...prev,
      selectedTools: newSelectedTools,
      activities: [...prev.activities, {
        type: 'info',
        message: `Auto-selected ${sortedTools.length} tools in prescribed order`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));
  };

  // Execute selected tools for current phase
  const executePhase = async () => {
    if (!wizardState.selectedFramework) {
      toast.error('No framework selected');
      return;
    }

    const currentPhaseData = wizardState.selectedFramework.phases.find(p => p.id === wizardState.currentPhase);
    const selectedToolIds = Object.keys(executionState.selectedTools).filter(
      toolId => executionState.selectedTools[toolId]
    );

    if (selectedToolIds.length === 0) {
      toast.error('Please select at least one tool to execute');
      return;
    }

    setExecutionState(prev => ({ 
      ...prev, 
      isExecuting: true, 
      isToolRunning: true, 
      terminalOutput: '', 
      toolOutput: '', 
      toolProgress: 0,
      activities: [...prev.activities, {
        type: 'info',
        message: `Starting ${currentPhaseData.title} phase (${wizardState.selectedFramework.name})`,
        timestamp: new Date().toLocaleTimeString()
      }]
    }));
    
    const phaseResults = {
      phase: currentPhaseData.id,
      framework: wizardState.selectedFramework.id,
      tools: [],
      findings: [],
      timestamp: new Date().toISOString()
    };

    try {
      // Sort tools by priority for execution order
      const toolsToExecute = selectedToolIds.map(toolId => {
        return currentPhaseData.tools.find(t => t.id === toolId);
      }).filter(Boolean).sort((a, b) => (a.priority || 999) - (b.priority || 999));

      for (let i = 0; i < toolsToExecute.length; i++) {
        const tool = toolsToExecute[i];
        
        if (!tool) continue;

        setExecutionState(prev => ({
          ...prev,
          currentTool: tool.name,
          toolProgress: Math.round(((i + 0.5) / toolsToExecute.length) * 100),
          activities: [...prev.activities, {
            type: 'info',
            message: `Executing ${tool.name} (priority ${tool.priority || 'N/A'})`,
            timestamp: new Date().toLocaleTimeString()
          }]
        }));

        try {
          // Prepare request body
          let requestBody = { target: wizardState.target };
          
          if (tool.endpoint.includes('/web/')) {
            if (wizardState.targetType === 'domain') {
              requestBody.target = `https://${wizardState.target}`;
            } else {
              requestBody.target = `http://${wizardState.target}`;
            }
          }

          const response = await fetch(`http://localhost:3001${tool.endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const result = await response.json();
          const output = result.output || result.data || JSON.stringify(result.result, null, 2) || 'Tool executed successfully';

          setExecutionState(prev => ({
            ...prev,
            terminalOutput: prev.terminalOutput + `\n=== ${tool.name} (Priority ${tool.priority}) ===\n${output}\n`,
            toolOutput: prev.toolOutput + `\n=== ${tool.name} ===\n${output}\n`,
            results: {
              ...prev.results,
              [tool.id]: { success: result.success !== false, output, timestamp: new Date(), priority: tool.priority }
            },
            activities: [...prev.activities, {
              type: 'success',
              message: `${tool.name} completed successfully`,
              timestamp: new Date().toLocaleTimeString()
            }]
          }));

          phaseResults.tools.push({
            id: tool.id,
            name: tool.name,
            priority: tool.priority,
            success: result.success !== false,
            output: output,
            findings: result.findings || [],
            metadata: result.metadata || {}
          });

          if (result.findings && result.findings.length > 0) {
            phaseResults.findings.push(...result.findings);
          }

        } catch (error) {
          console.error(`Tool ${tool.name} failed:`, error);
          
          let errorMessage = error.message || 'Tool execution failed';

          setExecutionState(prev => ({
            ...prev,
            terminalOutput: prev.terminalOutput + `\n=== ${tool.name} (Priority ${tool.priority}) ===\nERROR: ${errorMessage}\n`,
            toolOutput: prev.toolOutput + `\n=== ${tool.name} ===\nERROR: ${errorMessage}\n`,
            results: {
              ...prev.results,
              [tool.id]: { success: false, output: `Error: ${errorMessage}`, timestamp: new Date(), priority: tool.priority }
            },
            activities: [...prev.activities, {
              type: 'error',
              message: `${tool.name} failed: ${errorMessage}`,
              timestamp: new Date().toLocaleTimeString()
            }]
          }));

          phaseResults.tools.push({
            id: tool.id,
            name: tool.name,
            priority: tool.priority,
            success: false,
            output: `Error: ${errorMessage}`,
            findings: [],
            metadata: {}
          });
        }

        setExecutionState(prev => ({
          ...prev,
          toolProgress: Math.round(((i + 1) / toolsToExecute.length) * 100)
        }));
      }

      // Complete phase
      setWizardState(prev => ({
        ...prev,
        completedPhases: [...prev.completedPhases, prev.currentPhase],
        phaseData: {
          ...prev.phaseData,
          [prev.currentPhase]: phaseResults
        },
        findings: [...prev.findings, ...phaseResults.findings]
      }));

      setExecutionState(prev => ({
        ...prev,
        currentTool: null,
        isExecuting: false,
        isToolRunning: false,
        selectedTools: {},
        activities: [...prev.activities, {
          type: 'success',
          message: `${currentPhaseData.title} phase completed using ${wizardState.selectedFramework.name} methodology`,
          timestamp: new Date().toLocaleTimeString()
        }]
      }));

      const successfulTools = phaseResults.tools.filter(t => t.success).length;
      const totalTools = phaseResults.tools.length;
      
      if (successfulTools === totalTools) {
        toast.success(`${currentPhaseData.title} completed successfully (${successfulTools}/${totalTools} tools)`);
      } else if (successfulTools > 0) {
        toast.success(`${currentPhaseData.title} completed with ${successfulTools}/${totalTools} tools successful`);
      } else {
        toast.error(`${currentPhaseData.title} completed with errors`);
      }

      // Add guidance toast after a brief delay
      setTimeout(() => {
        toast.success(`🎉 ${currentPhaseData.title} phase complete! Click "Next Phase" to continue.`, {
          duration: 5000,
          icon: '👆'
        });
      }, 1500);

    } catch (error) {
      console.error('Phase execution error:', error);
      toast.error(`Error executing phase: ${error.message}`);
      setExecutionState(prev => ({ 
        ...prev, 
        isToolRunning: false, 
        currentTool: null,
        toolOutput: prev.toolOutput + `\nPhase execution failed: ${error.message}\n`
      }));
    }
  };

  // Move to next phase
  const nextPhase = () => {
    if (!wizardState.selectedFramework) return;
    
    const currentPhaseIndex = wizardState.selectedFramework.phases.findIndex(p => p.id === wizardState.currentPhase);
    if (currentPhaseIndex < wizardState.selectedFramework.phases.length - 1) {
      const nextPhase = wizardState.selectedFramework.phases[currentPhaseIndex + 1];
      setWizardState(prev => ({
        ...prev,
        currentPhase: nextPhase.id
      }));
      setExecutionState(prev => ({ 
        ...prev, 
        toolOutput: '',
        terminalOutput: '',
        selectedTools: {},
        activities: [...prev.activities, {
          type: 'info',
          message: `Moving to ${nextPhase.title} phase`,
          timestamp: new Date().toLocaleTimeString()
        }]
      }));
    }
  };

  // Reset wizard to initial state
  const resetWizard = () => {
    setWizardState({
      currentPhase: 'framework-selection',
      selectedFramework: null,
      target: '',
      targetType: 'domain',
      isRunning: false,
      completedPhases: [],
      phaseData: {},
      findings: [],
      startTime: null,
      endTime: null
    });
    setExecutionState({
      selectedTools: {},
      results: {},
      activities: [],
      terminalOutput: '',
      isExecuting: false,
      currentTool: null,
      toolOutput: '',
      toolProgress: 0,
      isToolRunning: false
    });
    toast.success('Wizard reset');
  };

  // Generate final report
  const generateReport = () => {
    const endTime = new Date().toISOString();
    const duration = new Date(endTime) - new Date(wizardState.startTime);
    
    setWizardState(prev => ({ ...prev, endTime }));

    const allTools = Object.values(wizardState.phaseData).reduce((acc, phase) => 
      acc.concat(phase.tools || []), []
    );
    
    const successfulTools = allTools.filter(t => t.success);
    const failedTools = allTools.filter(t => !t.success);
    
    const openPorts = [];
    const services = [];
    
    allTools.forEach(tool => {
      if (tool.success && tool.output) {
        if (tool.name.includes('Scan') && tool.output.includes('open')) {
          const portMatches = tool.output.match(/\d+\/tcp\s+open/g);
          if (portMatches) {
            openPorts.push(...portMatches.map(p => p.split('/')[0]));
          }
        }
        
        if (tool.name.includes('Service') && tool.output.includes('tcp')) {
          const serviceLines = tool.output.split('\n').filter(line => 
            line.includes('tcp') && line.includes('open')
          );
          services.push(...serviceLines);
        }
      }
    });

    const report = {
      framework: {
        id: wizardState.selectedFramework?.id,
        name: wizardState.selectedFramework?.name,
        description: wizardState.selectedFramework?.description
      },
      executiveSummary: {
        target: wizardState.target,
        targetType: wizardState.targetType,
        testDate: new Date(wizardState.startTime).toLocaleDateString(),
        duration: Math.round(duration / 1000) + ' seconds',
        methodology: wizardState.selectedFramework?.name || 'Unknown',
        overallRisk: failedTools.length > successfulTools.length ? 'Unable to assess' : 
                    openPorts.length > 20 ? 'High' : 
                    openPorts.length > 10 ? 'Medium' : 'Low',
        keyFindings: {
          openPorts: openPorts.length,
          identifiedServices: services.length,
          vulnerabilities: wizardState.findings.length,
          toolFailures: failedTools.length
        },
        recommendations: [
          openPorts.length > 10 ? 'Review and close unnecessary open ports' : null,
          failedTools.length > 0 ? 'Fix tool integration issues for complete assessment' : null,
          'Implement regular security scanning per ' + (wizardState.selectedFramework?.name || 'industry standards'),
          'Consider follow-up testing with additional ' + (wizardState.selectedFramework?.name || 'framework') + ' phases'
        ].filter(Boolean)
      },
      
      target: wizardState.target,
      targetType: wizardState.targetType,
      startTime: wizardState.startTime,
      endTime,
      duration,
      phases: Object.entries(wizardState.phaseData).map(([phaseId, data]) => ({
        ...data,
        phaseName: wizardState.selectedFramework?.phases.find(p => p.id === phaseId)?.title || `Phase ${phaseId}`,
        phaseOrder: wizardState.selectedFramework?.phases.find(p => p.id === phaseId)?.order || 0
      })).sort((a, b) => a.phaseOrder - b.phaseOrder),
      totalFindings: wizardState.findings.length,
      findings: wizardState.findings,
      summary: {
        totalPhases: wizardState.completedPhases.length,
        totalTools: allTools.length,
        successfulTools: successfulTools.length,
        failedTools: failedTools.length,
        successRate: Math.round((successfulTools.length / allTools.length) * 100)
      },
      
      discoveredAssets: {
        openPorts: [...new Set(openPorts)].slice(0, 20),
        services: services.slice(0, 10),
        ipAddresses: []
      }
    };

    return report;
  };

  // Computed values
  const currentPhaseData = wizardState.selectedFramework?.phases.find(p => p.id === wizardState.currentPhase);
  const phases = wizardState.selectedFramework?.phases || [];
  const frameworks = FRAMEWORKS;
  
  const totalPhases = phases.length - 1;
  const completedCount = wizardState.completedPhases.filter(p => p !== 'target-input').length;
  const progressPercentage = Math.round((completedCount / totalPhases) * 100);

  // Check if phase is complete
  const isPhaseComplete = (phaseId) => {
    return wizardState.completedPhases.includes(phaseId);
  };

  // Check if can proceed to next phase
  const canProceed = () => {
    if (wizardState.currentPhase === 'target-input') {
      return wizardState.target.length > 0;
    }
    return isPhaseComplete(wizardState.currentPhase);
  };

  // Check if wizard is complete
  const isWizardComplete = () => {
    return wizardState.currentPhase === 'reporting' || 
           wizardState.completedPhases.includes('reporting');
  };

  const value = {
    // State
    wizardState,
    executionState,
    
    // Computed values
    currentPhaseData,
    phases,
    frameworks,
    progressPercentage,
    
    // Actions
    selectFramework,
    startWizard,
    toggleTool,
    autoSelectToolsByPriority,
    executePhase,
    nextPhase,
    resetWizard,
    generateReport,
    
    // Helpers
    isPhaseComplete,
    canProceed,
    isWizardComplete
  };

  return (
    <SimplePentestContext.Provider value={value}>
      {children}
    </SimplePentestContext.Provider>
  );
};

export const useSimplePentest = () => {
  const context = useContext(SimplePentestContext);
  if (!context) {
    throw new Error('useSimplePentest must be used within a SimplePentestProvider');
  }
  return context;
}; 