import React, { createContext, useContext, useState, useCallback } from 'react';
import toast from 'react-hot-toast';

const PentestWizardContext = createContext();

export const usePentestWizard = () => {
  const context = useContext(PentestWizardContext);
  if (!context) {
    throw new Error('usePentestWizard must be used within a PentestWizardProvider');
  }
  return context;
};

// Standard Penetration Testing Methodology Phases
const WIZARD_PHASES = [
  {
    id: 'pre-engagement',
    title: 'Pre-Engagement',
    description: 'Define scope, objectives, and obtain proper authorization',
    icon: 'FileText',
    estimatedTime: '15-30 minutes',
    required: true,
    protocol: {
      objective: 'Establish testing parameters and boundaries',
      tasks: [
        'Define target scope and IP ranges',
        'Identify testing objectives',
        'Document rules of engagement',
        'Verify authorization and permissions'
      ],
      deliverables: ['Scope definition', 'Authorization documentation', 'Testing timeline'],
      criticalRequirements: ['Written authorization', 'Clear scope boundaries', 'Emergency contacts']
    }
  },
  {
    id: 'information-gathering',
    title: 'Information Gathering',
    description: 'Passive and active reconnaissance to gather target intelligence',
    icon: 'Search',
    estimatedTime: '30-60 minutes',
    required: true,
    protocol: {
      objective: 'Collect comprehensive intelligence about the target organization and infrastructure',
      tasks: [
        'OSINT collection from public sources',
        'DNS enumeration and zone transfers',
        'WHOIS queries and domain registration data',
        'Search engine reconnaissance',
        'Social media and personnel research',
        'Network range identification'
      ],
      deliverables: ['Target inventory', 'Infrastructure mapping', 'Personnel list', 'Attack surface documentation'],
      criticalRequirements: ['Valid targets identified', 'DNS records collected', 'IP ranges documented']
    }
  },
  {
    id: 'vulnerability-identification',
    title: 'Vulnerability Identification',
    description: 'Network scanning and service enumeration to identify potential attack vectors',
    icon: 'Radar',
    estimatedTime: '45-90 minutes',
    required: true,
    protocol: {
      objective: 'Discover live hosts, open ports, and running services to identify potential vulnerabilities',
      tasks: [
        'Host discovery scans',
        'Port scanning (TCP/UDP)',
        'Service version detection',
        'Operating system fingerprinting',
        'Service enumeration',
        'Banner grabbing',
        'SSL/TLS configuration analysis'
      ],
      deliverables: ['Live host inventory', 'Open port matrix', 'Service fingerprints', 'Vulnerability scan results'],
      criticalRequirements: ['Live hosts identified', 'Services enumerated', 'Version information collected']
    }
  },
  {
    id: 'vulnerability-analysis',
    title: 'Vulnerability Analysis',
    description: 'Analyze discovered services for security weaknesses and misconfigurations',
    icon: 'Shield',
    estimatedTime: '60-120 minutes',
    required: true,
    protocol: {
      objective: 'Identify and assess security vulnerabilities in discovered services and applications',
      tasks: [
        'Web application vulnerability scanning',
        'Database security assessment',
        'Network service vulnerability testing',
        'SSL/TLS security analysis',
        'Authentication mechanism testing',
        'Configuration review',
        'Default credential testing'
      ],
      deliverables: ['Vulnerability assessment report', 'Risk prioritization matrix', 'Proof-of-concept documentation'],
      criticalRequirements: ['Vulnerabilities catalogued', 'Risk levels assigned', 'False positives filtered']
    }
  },
  {
    id: 'exploitation',
    title: 'Exploitation',
    description: 'Controlled exploitation attempts to validate vulnerabilities and assess impact',
    icon: 'Zap',
    estimatedTime: '60-180 minutes',
    required: true,
    protocol: {
      objective: 'Safely exploit validated vulnerabilities to demonstrate real-world impact',
      tasks: [
        'Exploit development and testing',
        'SQL injection testing',
        'Cross-site scripting validation',
        'Authentication bypass attempts',
        'Privilege escalation testing',
        'File inclusion/upload testing',
        'Buffer overflow exploitation'
      ],
      deliverables: ['Exploitation evidence', 'Impact assessment', 'Compromise proof', 'Access documentation'],
      criticalRequirements: ['Safe exploitation methods', 'Impact documented', 'No system damage']
    }
  },
  {
    id: 'reporting',
    title: 'Reporting & Documentation',
    description: 'Comprehensive documentation of findings, risks, and remediation recommendations',
    icon: 'FileText',
    estimatedTime: '90-180 minutes',
    required: true,
    protocol: {
      objective: 'Provide comprehensive documentation of security findings and actionable recommendations',
      tasks: [
        'Executive summary preparation',
        'Technical findings documentation',
        'Risk assessment and prioritization',
        'Remediation recommendations',
        'Evidence compilation',
        'Methodology documentation',
        'Timeline and scope verification'
      ],
      deliverables: ['Executive summary', 'Technical report', 'Remediation roadmap', 'Evidence package'],
      criticalRequirements: ['All findings documented', 'Recommendations provided', 'Evidence preserved']
    }
  }
];

export const PentestWizardProvider = ({ children }) => {
  const [wizardState, setWizardState] = useState({
    currentPhaseIndex: 0,
    completedPhases: [],
    phaseData: {},
    findings: [],
    evidence: [],
    timeline: [],
    metadata: {
      startTime: null,
      endTime: null,
      totalDuration: 0,
      testId: null,
      tester: '',
      organization: '',
      testType: '',
      methodology: 'OWASP Testing Guide v4.0 / NIST SP 800-115'
    }
  });

  const [currentPhase, setCurrentPhase] = useState(WIZARD_PHASES[0]);
  const [phaseProgress, setPhaseProgress] = useState({});

  // Initialize wizard with engagement parameters
  const initializeWizard = useCallback((engagementData) => {
    const startTime = new Date().toISOString();
    
    setWizardState(prev => ({
      ...prev,
      metadata: {
        ...prev.metadata,
        ...engagementData,
        startTime,
        testId: `PT-${Date.now()}`
      },
      timeline: [{
        timestamp: startTime,
        phase: 'pre-engagement',
        event: 'Penetration test engagement initiated',
        details: engagementData
      }]
    }));

    toast.success('Penetration testing wizard initialized');
  }, []);

  // Complete current phase and advance
  const completePhase = useCallback((phaseId, phaseResults) => {
    const phaseIndex = WIZARD_PHASES.findIndex(p => p.id === phaseId);
    const phase = WIZARD_PHASES[phaseIndex];
    
    if (!phase) {
      toast.error('Invalid phase ID');
      return;
    }

    const completionTime = new Date().toISOString();

    setWizardState(prev => ({
      ...prev,
      completedPhases: [...prev.completedPhases, phaseId],
      phaseData: {
        ...prev.phaseData,
        [phaseId]: {
          ...phaseResults,
          completedAt: completionTime,
          duration: Date.now() - new Date(prev.timeline[prev.timeline.length - 1]?.timestamp || prev.metadata.startTime).getTime()
        }
      },
      findings: [
        ...prev.findings,
        ...(phaseResults.findings || [])
      ],
      evidence: [
        ...prev.evidence,
        ...(phaseResults.evidence || [])
      ],
      timeline: [
        ...prev.timeline,
        {
          timestamp: completionTime,
          phase: phaseId,
          event: `${phase.title} phase completed`,
          details: {
            tasksCompleted: phaseResults.completedTasks?.length || 0,
            findingsCount: phaseResults.findings?.length || 0,
            duration: Date.now() - new Date(prev.timeline[prev.timeline.length - 1]?.timestamp || prev.metadata.startTime).getTime()
          }
        }
      ]
    }));

    // Auto-advance to next phase
    if (phaseIndex < WIZARD_PHASES.length - 1) {
      setCurrentPhase(WIZARD_PHASES[phaseIndex + 1]);
      setWizardState(prev => ({
        ...prev,
        currentPhaseIndex: phaseIndex + 1
      }));
      
      toast.success(`${phase.title} completed! Advancing to ${WIZARD_PHASES[phaseIndex + 1].title}`);
    } else {
      // Final phase completed
      setWizardState(prev => ({
        ...prev,
        metadata: {
          ...prev.metadata,
          endTime: completionTime,
          totalDuration: Date.now() - new Date(prev.metadata.startTime).getTime()
        }
      }));
      
      toast.success('Penetration testing assessment completed!');
    }
  }, []);

  // Add finding with automatic risk classification
  const addFinding = useCallback((finding) => {
    const enhancedFinding = {
      ...finding,
      id: `finding-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      discoveredAt: new Date().toISOString(),
      phase: currentPhase.id,
      riskScore: calculateRiskScore(finding),
      cvssScore: finding.cvssScore || null,
      remediation: finding.remediation || generateRemediationSuggestion(finding)
    };

    setWizardState(prev => ({
      ...prev,
      findings: [...prev.findings, enhancedFinding]
    }));

    toast.success(`Finding added: ${finding.title}`);
  }, [currentPhase]);

  // Calculate risk score based on finding attributes
  const calculateRiskScore = (finding) => {
    let score = 0;
    
    const severityScores = { 'Critical': 9, 'High': 7, 'Medium': 5, 'Low': 3, 'Informational': 1 };
    score += severityScores[finding.severity] || 3;
    
    if (finding.exploitable) score += 2;
    if (finding.remoteExploitable) score += 1;
    if (finding.authenticated === false) score += 1;
    if (finding.dataExposure) score += 2;
    if (finding.systemCompromise) score += 3;
    if (finding.networkAccess) score += 1;
    
    return Math.min(score, 10);
  };

  // Generate remediation suggestions
  const generateRemediationSuggestion = (finding) => {
    const suggestions = {
      'SQL Injection': 'Implement parameterized queries and input validation',
      'Cross-Site Scripting': 'Implement output encoding and Content Security Policy',
      'Authentication Bypass': 'Review authentication logic and implement multi-factor authentication',
      'Privilege Escalation': 'Review user permissions and implement principle of least privilege',
      'Information Disclosure': 'Remove sensitive information from error messages and responses',
      'Insecure Configuration': 'Review and harden system configuration according to security benchmarks'
    };
    
    return suggestions[finding.type] || 'Review and remediate according to security best practices';
  };

  // Generate comprehensive report
  const generateReport = useCallback(() => {
    return {
      metadata: wizardState.metadata,
      executiveSummary: {
        testScope: wizardState.phaseData['pre-engagement']?.scope || 'Not defined',
        methodology: wizardState.metadata.methodology,
        testDuration: wizardState.metadata.totalDuration,
        findingsOverview: {
          total: wizardState.findings.length,
          critical: wizardState.findings.filter(f => f.severity === 'Critical').length,
          high: wizardState.findings.filter(f => f.severity === 'High').length,
          medium: wizardState.findings.filter(f => f.severity === 'Medium').length,
          low: wizardState.findings.filter(f => f.severity === 'Low').length,
          informational: wizardState.findings.filter(f => f.severity === 'Informational').length
        },
        riskRating: calculateOverallRisk(),
        keyFindings: wizardState.findings.sort((a, b) => b.riskScore - a.riskScore).slice(0, 5)
      },
      technicalFindings: wizardState.findings.map(finding => ({
        ...finding,
        phase: WIZARD_PHASES.find(p => p.id === finding.phase)?.title || finding.phase
      })),
      methodology: {
        phasesCompleted: wizardState.completedPhases.map(phaseId => 
          WIZARD_PHASES.find(p => p.id === phaseId)
        ),
        timeline: wizardState.timeline,
        coverage: Math.round((wizardState.completedPhases.length / WIZARD_PHASES.length) * 100)
      },
      evidence: wizardState.evidence,
      rawData: wizardState.phaseData
    };
  }, [wizardState]);

  const calculateOverallRisk = () => {
    if (wizardState.findings.length === 0) return 'Low';
    
    const criticalCount = wizardState.findings.filter(f => f.severity === 'Critical').length;
    const highCount = wizardState.findings.filter(f => f.severity === 'High').length;
    
    if (criticalCount > 0) return 'Critical';
    if (highCount > 2) return 'High';
    if (highCount > 0) return 'Medium';
    return 'Low';
  };

  const value = {
    wizardState,
    currentPhase,
    phaseProgress,
    phases: WIZARD_PHASES,
    initializeWizard,
    completePhase,
    addFinding,
    generateReport,
    isPhaseCompleted: (phaseId) => wizardState.completedPhases.includes(phaseId),
    canNavigateToPhase: (phaseId) => {
      const phaseIndex = WIZARD_PHASES.findIndex(p => p.id === phaseId);
      const requiredPrevious = WIZARD_PHASES.slice(0, phaseIndex).filter(p => p.required);
      return requiredPrevious.every(p => wizardState.completedPhases.includes(p.id));
    },
    getPhaseData: (phaseId) => wizardState.phaseData[phaseId] || {},
    isWizardComplete: () => wizardState.completedPhases.includes('reporting'),
    getTotalProgress: () => Math.round((wizardState.completedPhases.length / WIZARD_PHASES.length) * 100)
  };

  return (
    <PentestWizardContext.Provider value={value}>
      {children}
    </PentestWizardContext.Provider>
  );
}; 