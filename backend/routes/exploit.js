const express = require('express');
const { exec } = require('child_process');
const router = express.Router();
const OutputParser = require('../utils/parser');
const storage = require('../utils/storage');

// Validate URL format
function validateUrl(url) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

// SQLMap SQL injection testing
router.post('/sqlmap', async (req, res) => {
  try {
    const { 
      target, 
      method = 'GET',
      data = '',
      risk = 1,
      level = 1,
      batch = true
    } = req.body;

    if (!target) {
      return res.status(400).json({
        error: 'Target URL is required'
      });
    }

    if (!validateUrl(target)) {
      return res.status(400).json({
        error: 'Invalid URL format. Use http:// or https://'
      });
    }

    if (risk < 1 || risk > 3) {
      return res.status(400).json({
        error: 'Risk level must be between 1 and 3'
      });
    }

    if (level < 1 || level > 5) {
      return res.status(400).json({
        error: 'Level must be between 1 and 5'
      });
    }

    // Build sqlmap command
    let command = `sqlmap -u "${target}"`;
    
    if (method.toUpperCase() === 'POST' && data) {
      command += ` --data="${data}"`;
    }
    
    command += ` --risk=${risk}`;
    command += ` --level=${level}`;
    
    if (batch) {
      command += ' --batch'; // Non-interactive mode
    }
    
    // Basic detection only for safety
    command += ' --dbs'; // Enumerate databases
    command += ' --random-agent'; // Use random User-Agent
    command += ' --timeout=30'; // Connection timeout
    
    console.log('Executing sqlmap scan (command sanitized for logging)');
    
    exec(command, { timeout: 600000 }, async (error, stdout, stderr) => {
      if (error) {
        console.error('SQLMap error:', error);
        return res.status(500).json({
          error: 'Failed to execute sqlmap command',
          details: error.message,
          suggestion: 'Make sure sqlmap is installed and accessible in PATH'
        });
      }

      const parsedResult = OutputParser.parseSqlmapOutput(stdout);
      
      // Save result to storage
      const saveResult = await storage.saveScanResult('sqlmap', target, parsedResult, 'sql-injection');
      
      res.json({
        success: true,
        tool: 'sqlmap',
        target: target,
        method: method,
        risk: risk,
        level: level,
        result: parsedResult,
        scan_id: saveResult.scan_id,
        raw_output: stderr || null
      });
    });

  } catch (error) {
    console.error('SQLMap route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// SQLMap database enumeration (follow-up after finding injection)
router.post('/sqlmap/enumerate', async (req, res) => {
  try {
    const { 
      target, 
      database = '',
      table = '',
      column = '',
      method = 'GET',
      data = ''
    } = req.body;

    if (!target) {
      return res.status(400).json({
        error: 'Target URL is required'
      });
    }

    if (!validateUrl(target)) {
      return res.status(400).json({
        error: 'Invalid URL format'
      });
    }

    // Build sqlmap command for enumeration
    let command = `sqlmap -u "${target}" --batch --random-agent`;
    
    if (method.toUpperCase() === 'POST' && data) {
      command += ` --data="${data}"`;
    }

    if (database && table && column) {
      command += ` -D ${database} -T ${table} -C ${column} --dump`;
    } else if (database && table) {
      command += ` -D ${database} -T ${table} --columns`;
    } else if (database) {
      command += ` -D ${database} --tables`;
    } else {
      command += ' --dbs';
    }
    
    console.log('Executing sqlmap enumeration (command sanitized for logging)');
    
    exec(command, { timeout: 900000 }, async (error, stdout, stderr) => {
      if (error) {
        console.error('SQLMap enumeration error:', error);
        return res.status(500).json({
          error: 'Failed to execute sqlmap enumeration',
          details: error.message
        });
      }

      const parsedResult = OutputParser.parseSqlmapOutput(stdout);
      
      // Save result to storage
      const saveResult = await storage.saveScanResult('sqlmap', target, parsedResult, 'sql-enumeration');
      
      res.json({
        success: true,
        tool: 'sqlmap',
        scan_type: 'enumeration',
        target: target,
        database: database,
        table: table,
        column: column,
        result: parsedResult,
        scan_id: saveResult.scan_id,
        raw_output: stderr || null
      });
    });

  } catch (error) {
    console.error('SQLMap enumeration route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// XSS testing with basic payload injection (educational purposes)
router.post('/xss-test', async (req, res) => {
  try {
    const { target, parameter, payload = '<script>alert("XSS")</script>' } = req.body;

    if (!target || !parameter) {
      return res.status(400).json({
        error: 'Target URL and parameter are required'
      });
    }

    if (!validateUrl(target)) {
      return res.status(400).json({
        error: 'Invalid URL format'
      });
    }

    // Simple XSS test using curl
    const encodedPayload = encodeURIComponent(payload);
    const testUrl = `${target}${target.includes('?') ? '&' : '?'}${parameter}=${encodedPayload}`;
    
    const command = `curl -s -L "${testUrl}"`;
    
    console.log('Executing XSS test (educational purposes only)');
    
    exec(command, { timeout: 30000 }, async (error, stdout, stderr) => {
      if (error) {
        console.error('XSS test error:', error);
        return res.status(500).json({
          error: 'Failed to execute XSS test',
          details: error.message
        });
      }

      // Check if payload is reflected in response
      const isVulnerable = stdout.includes(payload.replace(/[<>]/g, ''));
      
      const result = {
        test_type: 'XSS Reflection Test',
        target: target,
        parameter: parameter,
        payload: payload,
        vulnerable: isVulnerable,
        response_length: stdout.length,
        timestamp: new Date().toISOString()
      };

      // Save result to storage
      const saveResult = await storage.saveScanResult('xss-test', target, result, 'xss-testing');
      
      res.json({
        success: true,
        tool: 'xss-test',
        target: target,
        parameter: parameter,
        result: result,
        scan_id: saveResult.scan_id,
        warning: 'This is for educational purposes only. Always get permission before testing.'
      });
    });

  } catch (error) {
    console.error('XSS test route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Exploit tool presets
router.get('/presets', (req, res) => {
  const presets = [
    {
      name: 'Basic SQL Injection Test',
      description: 'Low-risk SQL injection detection',
      endpoint: '/sqlmap',
      estimated_time: '5-15 minutes',
      parameters: { risk: 1, level: 1, batch: true },
      warning: 'Only use on systems you own or have permission to test'
    },
    {
      name: 'Comprehensive SQL Test',
      description: 'Medium-risk comprehensive SQL injection test',
      endpoint: '/sqlmap',
      estimated_time: '15-45 minutes',
      parameters: { risk: 2, level: 3, batch: true },
      warning: 'Only use on systems you own or have permission to test'
    },
    {
      name: 'Database Enumeration',
      description: 'Enumerate databases after finding injection',
      endpoint: '/sqlmap/enumerate',
      estimated_time: '5-20 minutes',
      warning: 'Only use on systems you own or have permission to test'
    },
    {
      name: 'XSS Reflection Test',
      description: 'Test for reflected XSS vulnerabilities',
      endpoint: '/xss-test',
      estimated_time: '30 seconds - 2 minutes',
      warning: 'Educational purposes only. Get permission before testing.'
    }
  ];

  res.json({
    success: true,
    presets: presets,
    disclaimer: 'These tools are for educational and authorized testing purposes only. Always ensure you have proper permission before testing any system.'
  });
});

// Security disclaimer endpoint
router.get('/disclaimer', (req, res) => {
  res.json({
    important_notice: 'ETHICAL HACKING DISCLAIMER',
    message: [
      'The tools provided in this module are for educational and authorized penetration testing purposes only.',
      'You must have explicit written permission from the system owner before conducting any security tests.',
      'Unauthorized access to computer systems is illegal and may result in criminal charges.',
      'The developers of HackNest are not responsible for any misuse of these tools.',
      'Always follow responsible disclosure practices when vulnerabilities are found.',
      'Use these tools only in controlled environments or against your own systems.'
    ],
    legal_warning: 'By using these tools, you acknowledge that you understand the legal implications and agree to use them responsibly and ethically.'
  });
});

module.exports = router; 